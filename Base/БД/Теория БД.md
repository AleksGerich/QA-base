---
tags:
---

---
***ACID*** (от англ. atomicity, consistency, isolation, durability) — атомарность, согласованность, изоляция, устойчивость. Набор требований к БД, который обеспечивает сохранность данных.

---
# БД и СУБД

**База данных (БД)** — это набор данных, хранящихся в структурированном виде. По сути это просто хранилище неких сведений, не более того.

**Система управления базами данных (СУБД)** — это совокупность языковых и программных средств, которая осуществляет доступ к данным, позволяет их создавать, менять и удалять, обеспечивает безопасность данных и т.д. (Создание и манипулирование)

![](Pasted%20image%2020241206103908.png)

## Рейтинг СУБД

- Oracle - реляционная СУБД
- MySQL - реляционная СУБД
- Microsoft SQL Server - реляционная СУБД
- PostgreSQL - реляционная СУБД
- MongoDB - документоориентированная СУБД
- Redis - хранилище по типу «ключ-значение»
- Snowflake - облачная реляционная СУБД
- Elasticsearch - поисковой движок
- IBM Db2 - реляционная СУБД
- SQLite - реляционная СУБД

---
# Реляционные БД

https://sql-academy.org/ru/guide/relation-databases
https://sql-academy.org/ru/guide/structure-of-relation-databases

---
# Key-value базы данных

Key-value базы данных – это тип баз данных, которые хранят данные как совокупность пар «ключ-значение», в которых ключ служит уникальным идентификатором.

То есть создаётся однозначное соответствие значения по ключу. Как ключи, так и значения могут представлять собой что угодно: от простых до сложных составных объектов.

***Общий вид:***
![](Pasted%20image%2020241206105433.png)

## Преимущества
- Скорость работы
- Простота модели хранения данных
- Гибкость: значения могут быть любыми, включая JSON

## Недостатки
- Плохо масштабируются по мере усложнения моделей данных
- Неэффективность при работе с группой записей
- Отсутствие языка запросов

Стандартная реализация не даёт никакого представления о том, что содержит фактическое значение — когда вы получаете значение с помощью ключа, у вас нет гарантии того, что вы получаете. Это означает, что вам придётся фильтровать или обрабатывать данные, которые вам не нужны, в коде вашего приложения. Как правило, это будет менее эффективно с точки зрения производительности по сравнению с выполнением большей части этой работы в базе данных.

Отсутствие языка запросов означает, что логика, которая обычно хранится в базе данных, теперь находится в коде вашего приложения, что может привести к сложности и усложнить поддержку кода

#### Яркий представитель: **Redis**

[Сурс](https://sql-academy.org/ru/guide/key-value-databases)

---
# Документоориентированные БД

**Документоориентированные базы данных** – это тип баз данных, направленный на хранение и запрос данных в виде документов, подобном JSON.

В отличие от других баз данных, документоориентированные оперируют «документами», сгруппированными по коллекциям. Документ представляет собой набор атрибутов (ключ и соответствующее ему значение). Значения могут быть как и простыми типами данных (строки, числа или даты), так и более сложными, такими как вложенные объекты, массивы и ссылки на другие документы

***Пример (MongoDB):***
![](Pasted%20image%2020241206133547.png)

В реляционных базах данных структура записей строго определена и каждая запись содержит одни и те же поля. Даже если поле не используется, оно присутствует, хоть и пустое.

В документоориентированных же БД используется другой подход: в них отсутствует схема данных, что позволяет добавлять новую информацию в некоторые записи, не требуя при этом, чтобы все остальные записи в базе данных имели одинаковую структуру.

Документы в базе данных адресуются с помощью уникального ключа, обычно это строка, которая генерируется автоматически. По нему можно, например, извлекать запись или ссылаться на другие документы.

Другой значимой особенностью документоориентированных баз данных является то, что помимо простого поиска документов по ключу, как в key-value базах данных, они предоставляют свой язык запросов, функционал, синтаксис и производительность которого отличается от одной реализации к другой

*@ (MongoDB): db.users.find({"name": "Daniel"}).count()*

#### Яркий представитель: [MongoDB](Base/БД/MongoDB)

[Сурс](https://sql-academy.org/ru/guide/document-oriented-databases)

---
# Про SQL

**SQL** — язык структурированных запросов (SQL, Structured Query Language), который используется в качестве эффективного способа сохранения данных, поиска их частей, обновления, извлечения и удаления из базы данных.

Обращение к реляционным СУБД осуществляется именно благодаря SQL. С помощью него выполняются все основные манипуляции с базами данных, например:

- Извлекать данные из базы данных
- Вставлять записи в базу данных
- Обновлять записи в базе данных
- Удалять записи из базы данных
- Создавать новые базы данных
- Создавать новые таблицы в базе данных
- Создавать хранимые процедуры в базе данных
- Создавать представления в базе данных
- Устанавливать разрешения для таблиц, процедур и представлений

## Диалекты SQL

Язык SQL – универсальный язык для всех реляционных систем управления базами данных, но многие СУБД вносят свои изменения в язык, применяемый в них, тем самым отступая от стандарта. Такие языки называют диалектами или расширениями языка.

Вот некоторые из них:

- T-SQL – диалект Microsoft SQL Server
- PL/SQL – диалект Oracle Database
- PL/pgSQL – диалект PostgreSQL

[Сурс](https://sql-academy.org/ru/guide/intro-sql)

---
#нормализация
# Нормализация БД

**Нормальный вид базы данных (НФ)** — это набор правил и критериев для структурирования базы данных, чтобы устранить избыточность данных и повысить целостность данных. Эти правила применяются к реляционным базам данных для того, чтобы организовать данные таким образом, чтобы минимизировать дублирование и зависимость между данными

#### Основные процессы:
- устранение избыточности данных
- устранение аномалий при добавлении, обновлении, удалении
- поддержание логической связи между таблицами

## Первая нормальная форма (1НФ)

###### Не должно быть дубликатов и составных данных

![[Pasted image 20241128163527.png]]

## Вторая нормальная форма (2НФ)

###### У каждой записи в базе данных должен быть первичный ключ (PK)

![[Pasted image 20241128163744.png]]

Номер чека - PK

## Третья нормальная форма (3НФ)

###### В записи не должно быть столбцов с неключевыми значениями, которые зависят от других неключевых значений

![[Pasted image 20241128164040.png]]

---
#целостность_БД
# Целостность БД

Целостность базы данных - это свойство, обеспечивающее корректность, точность и согласованность данных в системе. Предотвращает ошибок данных

## 1. Целостность сущностей (PK)

1. Гарантирует, что каждая строка в таблице имеет уникальный идентификатор.
2. Обычно обеспечивается использованием **первичного ключа (Primary Key)**:
    - Значение первичного ключа должно быть **уникальным**.
    - Первичный ключ не может содержать **NULL**.

![[Pasted image 20241128171609.png]]

## 2. Ссылочная целостность (связь ключей)

1. Обеспечивает корректность ссылок между таблицами через **внешние ключи (Foreign Keys)**.
2. Значение внешнего ключа должно:
    - Либо совпадать с существующим значением первичного ключа в связанной таблице.
    - Либо быть **NULL**.

![[Pasted image 20241128171757.png]]

## 3. Целостность Домена (столбца)

1. Гарантирует, что значения в столбце соответствуют определенному типу данных, диапазону или списку допустимых значений.
2. Достигается использованием:
    - Ограничений типов данных (например, INTEGER, VARCHAR).
    - Проверочных ограничений (CHECK).
    - Правил уникальности (UNIQUE).

![[Pasted image 20241128172338.png]]

## 4. Пользовательская целостность (бизнес-логика)

- Определяется специфическими правилами бизнеса или логикой приложения.
- Реализуется с помощью триггеров, процедур или других программных средств.

**Пример:**
- В таблице "Заказы" сумма заказа не может превышать определенное значение.
- Или, например, доставка не может быть назначена на выходные.

#### Способы обеспечения целостности

1. **Ограничения (Constraints):**
- PRIMARY KEY: уникальный идентификатор строки.
- FOREIGN KEY: поддержание связей между таблицами.
- UNIQUE: предотвращение дублирования данных.
- CHECK: проверка значений по правилам.
- NOT NULL: предотвращение пустых значений.

2. **Триггеры:**
- Автоматическое выполнение действий при добавлении, изменении или удалении записей

3. **Транзакции:**
- Группы операций, которые выполняются как единое целое. Если одна операция не выполнится, транзакция откатывается.

3. **Правильный дизайн схемы базы данных:**
- Нормализация и использование правильных типов данных.

---
#индексы
# Индексы

**Индекс** — это структура данных, создаваемая для увеличения производительности операций поиска. По сути, это отдельная структура, которая хранит ссылки на строки таблицы и помогает быстро находить нужные записи, аналогично тому, как оглавление книги помогает быстро находить нужную главу.

Когда запрос использует колонку, на которой есть индекс, система ищет данные через индекс, а не просматривает все записи в таблице последовательно.

#### Плюсы индексов:
- **Ускорение запросов**: Индексы позволяют базе данных быстро находить нужные строки, минуя полное сканирование таблицы.
- **Оптимизация операций выборки**: Особенно эффективны при работе с большими таблицами, где без индексов поиск может занимать значительно больше времени.

#### Минусы индексов (в общем): 
- **Затраты на хранение**: Индексы требуют дополнительного пространства на диске, так как создается отдельная структура данных.
- **Замедление вставки/обновления/удаления данных**: При каждом изменении данных в таблице индекс тоже должен обновляться, что может замедлить операции вставки и обновления.

#### Разновидности индексов

1.  ***Кластеризованные***
		
	- все значения при кластеризованном индексе *отсортированы* (либо по возрастанию, либо по убыванию)
		
	- Кластеризированный индекс может быть *только один*
		
	- Упорядоченные кластеризованным индексом данные в таблице *хранятся физически*, что увеличивает скорость поиска, но тратит память
		
	- При изменении данных таблиц меняется порядок -> индексированная таблица перестраивается, что является *затратным процессом*
		
2. ***Некластеризованные***
		
	- применяется к *неключевым столбцам*
		
	- *не упорядочивает данные физически*. Он хранит данные и индексы в разных местах
		
	- Листья некластеризованного индекса содержат только те столбцы таблицы, по которым определен данный индекс. Это означает, что системе запросов необходима дополнительная операция для извлечения требуемых данных.
		
	- Некластеризованные индексы нельзя отсортировать 
		
	- Можно создать более одного некластеризованного индекса
		
	- При использовании некластеризованного индекса можно добавить уникальный ключ для таблицы.

![[Pasted image 20241021130235.png]]

#### Основные типы индексов

1. **Обычные (B-tree) индексы**
	- Это наиболее распространенный тип индексов, основанный на **B-деревьях**. Он хранит данные в отсортированном порядке, что ускоряет поиск, вставку и удаление данных (хорошо подходят для равенства и диапазонных запросов)
2. **Уникальные индексы (Unique index)**:
	- Гарантируют, что все значения в проиндексированной колонке будут уникальными. 
	- (@: PRIMARY KEY)
3. **Неуникальный (Non-unique index)**:
	- индекс, при котором значения могут повторяться
4. **Полнотекстовые индексы (Full-text)**:
	- Эти индексы предназначены для быстрого поиска текста в больших объемах текстовых данных. Они полезны для поиска по ключевым словам или фразам, как в случае поиска по статьям, книгам или заметкам
5. **Хэш-индексы**:
	- В некоторых СУБД (например, в MySQL для таблиц с движком **Memory**) используются **хэш-индексы**, которые обеспечивают доступ к данным по точному значению столбца. В отличие от B-tree индексов, хэш-индексы не поддерживают диапазонные запросы. 
	- (@: SELECT * FROM table WHERE column = 'value')
6. **Составные (многоколонковые) индексы**:
	- Это индексы, создаваемые сразу на нескольких столбцах. Они полезны, когда запросы часто фильтруют данные по нескольким колонкам одновременно. В данном типе индекса расположение полей является важным.

---

