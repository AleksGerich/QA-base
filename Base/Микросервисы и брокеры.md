---
tags:
  - брокеры
  - брокеры_сообщений
  - kafka
  - rabbitmq
  - тестирование_брокеров
  - микросервисы
  - тестирование_микросервисов
---

---

#брокеры #брокеры_сообщений
# Брокеры сообщений

**Брокеры сообщений (queue brokers)** — это системы для управления и обработки сообщений между приложениями, особенно в [распределенных системах](Интерфейсы.md#Распределенные/системы), где важно организовать эффективный обмен данными и обеспечить надежную доставку сообщений. Эти брокеры играют роль посредников, обеспечивая хранение и пересылку сообщений между отправителями и получателями. Примеры таких брокеров включают Apache Kafka, RabbitMQ, ActiveMQ, и другие.

Брокер сообщений представляет собой тип построения архитектуры, при котором элементы системы «общаются» друг с другом с помощью посредника. Благодаря его работе происходит снятие нагрузки с веб-сервисов, так как им не приходится заниматься пересылкой сообщений: всю сопутствующую этому процессу работу он берёт на себя.

![[Pasted image 20241024170932.png]]
### Основные функции брокеров очередей
	
1. **Асинхронное взаимодействие**: Брокеры очередей позволяют приложениям обмениваться сообщениями асинхронно, что уменьшает задержки и разрывы при взаимодействии.
2. **Буферизация сообщений**: Они сохраняют сообщения в очереди, если получатель временно недоступен, и доставляют их позже.
3. **Распределенная обработка**: Брокеры могут распределять сообщения между несколькими потребителями для повышения производительности и масштабируемости.
4. **Долговечность сообщений**: Брокеры очередей гарантируют, что сообщения не будут потеряны в случае сбоев системы.

![[Pasted image 20241024171408.png]]

---
## Producer и consumer

Можно сказать, что в работе любого брокера сообщений используются две основные сущности: **producer** (отвечает за создание сообщений и их отправку в брокер) и **consumer** (отвечает за получение и обработку сообщений)

#### Взаимодействие producer и consumer:
1. **Producer** отправляет сообщение в брокер, который сохраняет его в соответствующей очереди или топике.
2. **Consumer** подписывается на очередь или топик и получает сообщение, когда оно становится доступным.
3. Брокер может управлять количеством consumers, которые будут обрабатывать сообщения параллельно, что повышает производительность и устойчивость системы

## Основные схемы работы брокеров

### 1. Сообщение отправляется напрямую от отправителя к получателю (точка-точка)

Это простая схема, при которой каждое сообщение отправляется от одного отправителя (**producer**) к одному получателю (**consumer**). Сообщения помещаются в очередь, и каждый consumer забирает из неё сообщение по мере обработки. После получения сообщения оно удаляется из очереди.

![[Pasted image 20241024162855.png]]

#### Характеристики:
- **Очередь**: Сообщения отправляются в очередь, и каждый consumer получает уникальное сообщение.
- **Единственный получатель**: Каждое сообщение может быть обработано только одним потребителем.
- **Использование в системах**: Такая схема подходит для систем, где важна точная доставка сообщения одному потребителю, например, обработка банковских транзакций или выполнения заданий на сервере.

#### @:
- **RabbitMQ**: В модели "точка-точка" producer отправляет сообщения в очередь, а consumer забирает их по одному.

К очередям применяется термин «надежные» («durable»). _Надежность_ — это свойство сервиса, которое гарантирует, что система обмена сообщениями будет сохранять сообщения при отсутствии активных подписчиков до тех пор, пока потребитель не подпишется на очередь для доставки сообщений.

Надежность часто путают с _персистентностью_ и, хотя эти два термина взаимозаменяемы, они выполняют разные функции:
- **Персистентность** определяет, записывает ли сообщение система обмена сообщениями в какого-либо рода хранилище между получением и отправкой его потребителю (не обязательно)

### 2. Схема публикации/подписки (Publish/Subscribe)

В этой схеме один отправитель может публиковать сообщения для нескольких подписчиков. Producer публикует сообщение в **топик** (в Kafka) или **обменник** (в RabbitMQ), а затем несколько consumers, подписанные на этот топик, получают это сообщение. Важно, что одно и то же сообщение может быть получено несколькими получателями одновременно.

В классических системах обмена сообщениями модель обмена сообщениями «публикация-подписка» реализуется через _топики_. Топик предоставляет такой же способ широковещания, как и механизм конференц-связи. Когда сообщение отправляется в топик, оно распределяется _по всем подписанным пользователям_.

Топики обычно _ненадежные (nondurable)_. Как и слушатель, который не слышит, что говорится на конференц-звонке, когда слушатель отключается, подписчики топика пропускают любые сообщения, которые отправляются в тот момент, когда они находятся в автономном режиме. По этой причине можно сказать, что топики предоставляют гарантию доставки _не более одного раза_ для каждого потребителя

![[Pasted image 20241024163421.png]]

#### Характеристики:
- **Топики**: Сообщения отправляются в топик или обменник, и все подписчики этого топика получают сообщение.
- **Несколько получателей**: Одно сообщение может быть отправлено нескольким потребителям.
- **Использование в системах**: Такая схема используется, когда сообщение должно быть обработано несколькими службами одновременно, например, система уведомлений или рассылка данных для аналитики в реальном времени.

#### @:
- **Kafka**: В модели "Publish/Subscribe" producer публикует сообщение в топик, а несколько consumers, подписанные на этот топик, могут его получить.

Обмен сообщениями типа «публикация-подписка» обычно используется, когда сообщения носят информационный характер, и потеря одного сообщения — не особо значима. Например, топик может передавать показания температуры от группы датчиков один раз в секунду. Система, которая интересуется текущей температурой и которая подписывается на топик, не будет переживать, если она пропустит сообщение — другое поступит в ближайшее время.

### 3. Гибридная схема

Сценарии использования часто требуют совмещения моделей обмена сообщениями «публикация-подписка» и «точка-точка», например, когда нескольким системам требуется копия сообщения, и для предотвращения потери сообщения требуется как надежность, так и персистентность.  
  
В этих случаях требуется адресат (destination) (общий термин для очередей и топиков), который распределяет сообщения в основном как топик, так, что каждое сообщение отправляется в отдельную систему, заинтересованную в этих сообщениях, но и также в которой каждая система может определить несколько потребителей, которые получают входящие сообщения, что больше похоже на очередь. Тип чтения в этом случае — _один раз для каждой заинтересованной стороны_. 

Гибридные адресаты часто требуют надежности (durability), так что, если потребитель отключается, сообщения, которые отправляются в это время, принимаются после повторного подключения потребителя.  
  
Гибридные модели не новы и могут применяться в большинстве систем обмена сообщениями, включая как ActiveMQ (через виртуальные или составные адресаты, которые объединяют топики и очереди), так и Kafka (неявно, как фундаментальное свойство дизайна её адресата).  
  
Теперь, когда у нас есть некоторая базовая терминология и понимание того, для чего нам могла бы пригодиться система обмена сообщениями, давайте перейдем к деталям.

#### @:
Веб-сайт магазина помещает сообщения о заказах в «очередь сообщений». Основным потребителем этих сообщений является исполнительная система. Кроме того, система аудита должна иметь копии этих сообщений о заказах для последующего отслеживания. Обе системы не могут пропускать сообщения, даже если сами системы в течение некоторого времени недоступны. Веб-сайт не должен знать о других системах.

---
## Когда использовать

1. Если в рамках системы есть действия, которые требуют для своего выполнения **много времени и потребляют много ресурсов**, при этом они не требуют немедленного результата.

2. **Микросервисы**. если ваша система достаточно сложна и состоит из отдельных сервисов, то для их координации можно использовать брокер сообщений, который в этом случае будет выступать в роли как бы центрального роутера. Каждый сервис подписывается только на свой тип сообщений, выстраивается определённая логика их обработки.

3. **Мобильные приложения**. здесь возможен вариант с задействованием push-уведомлений, когда множество смартфонов с установленным приложением подписаны на определённую тему. Если в ней публикуется какая-либо новость, то подписанный смартфон выводит уведомление.

4. **Транзакционные системы.** если какое-то действие системы состоит из множества отдельных этапов, каждый из которых выполняется отдельным элементом системы, то в этом случае брокер сообщений может выступить в роли своеобразной «доски уведомлений». Каждый сервис отписывается после того, как его этап общей задачи был выполнен. После этого в работу вступает следующий сервис, обрабатывающий, соответственно, следующий этап общей задачи.

![[Pasted image 20241024171711.png]]
#### Недостатки брокеров сообщений:
	
1.  **Усложнение системы** в целом как таковой, так как в ней появляется ещё один элемент. Кроме того, возникает зависимость от надёжности распределённой сети, а также потенциальная возможность возникновения проблем из-за потребности в непротиворечивости данных, так как некоторые элементы системы могут обладать неактуальными данными.
	
2. Из-за асинхронной работы всей системы, а также её распределённого характера могут **возникать ошибки**, выяснение сути которых может стать непростой задачей.
	
3. **Освоение** подобных систем является не самым простым вопросом и может занять существенное время.

### Примеры использования брокеров сообщений:

1. **Обработка заказов в интернет-магазине**: Сообщения о заказах могут отправляться через брокер очередей для асинхронной обработки — проверки оплаты, подготовки к отправке и т.д.
2. **Аналитика в реальном времени**: Системы потоковой аналитики используют брокеров сообщений для передачи данных от датчиков или других источников.
3. **Микросервисная архитектура**: Брокеры помогают организовать взаимодействие между микросервисами, обеспечивая независимость и асинхронность.

[Сурс из сбера](https://habr.com/ru/companies/sberbank/articles/669456/)

---
#брокеры #брокеры_очередей #kafka
# Apache Kafka

**Apache Kafka** — это один из самых популярных брокеров сообщений, разработанный для обработки потоков данных в режиме реального времени. В отличие от традиционных систем очередей сообщений, Kafka ориентирован на массовую обработку потоков событий с высокой пропускной способностью.

Apache Kafka представляет собой брокер, который, в отличие от RabbitMQ, хранит все сообщения в виде распределённого лога, причём гарантируется, что порядок сообщений отражает последовательность их поступления в систему. Сообщение в этом логе хранится в течение определённого времени, и работа построена таким образом, что продюсеры пишут новые сообщения в систему, а подписчики сами их запрашивают. При надобности организуется хранение сообщений в рамках тем. То есть можно сказать, что происходит определённого рода группировка сообщений в рамках одной темы.

Apache Kafka больше предназначен для построения высоконагруженных систем сферы bigdata, так как сама его парадигма параллельной обработки, репликации позволяет создавать достаточно надёжные системы и обеспечивать неограниченные возможности по масштабированию. Высокая пропускная способность, а также возможности извлечения сообщений из очереди за определённый период времени (так как они хранятся в очереди, как мы сказали ранее, именно в том порядке, в каком были отправлены) являются мощным инструментом для анализа происходящего в историческом разрезе.

### Основные особенности:

1. **Событийная архитектура**: Kafka работает по принципу логов, где сообщения сохраняются в виде непрерывных потоков событий.
2. **Топики (Topics)**: Сообщения организованы в топики — логические каналы для передачи данных.
	- Топики разделяются на партиции - более подробное разделение
		- По порядку
		- По ключу
3. **Продюсеры и консюмеры**: Продюсеры отправляют сообщения в топики, а консюмеры подписываются на них для получения сообщений.
4. **Масштабируемость**: Kafka может работать в кластере с горизонтальным масштабированием, что делает его подходящим для больших объемов данных.

#### Партиции
Партиции находятся внутри топиков. Партиции ускоряют работу брокеров


**Использование Kafka**: Kafka применяется для построения событийно-ориентированных архитектур, потоковой аналитики, логгирования данных и интеграции микросервисов. Это делает его идеальным для систем, работающих с большими объемами данных в реальном времени.

[Визуализация работы Kafka](https://softwaremill.com/kafka-visualisation/)

---
#брокеры #брокеры_очередей #rabbitmq #rabbit
# RabbitMQ

**RabbitMQ** — это еще один популярный брокер очередей, который чаще используется в традиционных системах обмена сообщениями.

RabbitMQ позволяет сконфигурировать даже весьма сложные сценарии доставки сообщений, что даёт разработчикам гибкость в построении нужного сценария информирования о событиях. При этом следует учитывать, что порядок доставки сообщений не гарантируется.

### Основные особенности:

1. **Очереди**: Сообщения организованы в очереди, и они передаются между продюсерами и консюмерами.
2. **Маршрутизация сообщений**: RabbitMQ предлагает расширенные механизмы маршрутизации сообщений через обменники (exchanges) и ключи маршрутизации.
3. **Поддержка различных протоколов**: RabbitMQ поддерживает AMQP, MQTT и другие протоколы для работы с различными типами систем.

**Использование RabbitMQ**: Он широко применяется для интеграции микросервисов, задач асинхронной обработки данных, а также в системах, где важна надежная доставка сообщений.

### Отличия Kafka и RabbitMQ:

- **Архитектура**: Kafka использует модель публикации-подписки с логом, а RabbitMQ — классическую модель очередей с продюсерами и консюмерами.
- **Пропускная способность**: Kafka подходит для высоких объемов данных и потоков событий, тогда как RabbitMQ лучше для задач с низкой задержкой и точной доставкой сообщений.
- **Масштабируемость**: Kafka лучше масштабируется горизонтально за счет распределенной архитектуры.

### Различия в подходах Kafka и RabbitMQ:

- **Kafka** использует модель публикации-подписки, где consumers подписываются на топики, а сообщения хранятся в журнале (log) до тех пор, пока они не будут прочитаны.
- **RabbitMQ** реализует классическую модель очередей, где сообщения направляются конкретным consumers через маршрутизацию (routing).

### Различия по "уму" consumer-а:

- умный консюмер в кафке следит за сообщениями
- глупый консюмерв MQrabbit не следит

---
#тестирование_брокеров #брокеры #брокеры_очередей 
# Тестирование брокеров очередей

Тестирование брокеров сообщений, таких как **Apache Kafka** или **RabbitMQ**, требует комплексного подхода, поскольку брокеры обеспечивают асинхронное взаимодействие между сервисами и масштабируемую передачу данных. Для тестировщика задача состоит в проверке корректности работы передачи сообщений, управления очередями, а также соблюдения гарантий доставки сообщений. Вот основные шаги и методы, которые помогут протестировать брокеры:

### 1. **Функциональное тестирование**

Основной задачей здесь является проверка того, что сообщения корректно передаются между producer и consumer. Тестировщик проверяет:

- Может ли **producer** отправлять сообщения в очередь/топик.
- Может ли **consumer** получать эти сообщения.
- Корректно ли сообщения удаляются из очереди после получения.

#### @:
- Отправка тестового сообщения и проверка, что оно было доставлено конкретному consumer.
*python*
`# Проверка отправки и получения сообщения 
producer.send('test_topic', value={'key': 'value'}) 
message = consumer.poll(timeout_ms=1000)  
assert message is not None assert message.value == {'key': 'value'}`

### 2. **Тестирование устойчивости (Failover testing)**

Это тестирование направлено на проверку поведения брокера в условиях отказов. Брокер должен корректно восстанавливаться после сбоев и продолжать доставку сообщений. Тестировщик может:

- Проверить, что произойдет, если **consumer** или **producer** упадет в середине процесса.
- Убедиться, что сообщения не теряются и остаются в очереди до тех пор, пока не будут обработаны.

Пример сценария:

1. Остановить consumer и отправить несколько сообщений от producer.
2. Запустить consumer и проверить, что он получил все сообщения после перезапуска.

### 3. **Тестирование производительности**

Цель — убедиться, что брокер может обрабатывать большой объем сообщений без снижения производительности. Тестировщик должен:

- Измерять скорость передачи сообщений (throughput).
- Проверять задержку доставки (latency) при разных нагрузках.
- Определять, как брокер обрабатывает ситуацию, когда очередь переполнена.

**Пример инструмента**: Для Kafka можно использовать утилиты, такие как **kafka-producer-perf-test.sh** и **kafka-consumer-perf-test.sh**, чтобы измерить производительность.

### 4. **Тестирование конфигурации и безопасности**

Тестировщик проверяет настройки прав доступа, шифрования сообщений и изоляции данных. Это важно для обеспечения безопасности в производственной среде.

- **Аутентификация**: Проверить, что только авторизованные пользователи могут отправлять или получать сообщения.
- **Шифрование**: Проверить, что сообщения передаются по зашифрованным каналам.

### 5. **Тестирование конкуренции (Concurrency testing)**

Брокеры сообщений часто работают в многопоточном режиме, и важно проверить, что они корректно обрабатывают большое количество параллельных подключений.

- Запуск нескольких **producer** и **consumer** одновременно.
- Проверка корректности обработки сообщений при высокой конкуренции за доступ к очередям.

### 6. **Тестирование с задержкой и повторной попыткой (Retry/Backoff testing)**

Тестировщик должен проверить, как брокер обрабатывает повторные попытки доставки сообщений при временных сбоях.

- Если consumer временно недоступен, брокер должен сохранить сообщение для повторной доставки.

### 7. **Тестирование дедупликации сообщений**

Некоторые системы могут отправлять дубликаты сообщений. Тестировщик должен проверить, что:

- Сообщения доставляются только один раз (idempotent delivery).
- Сообщения не дублируются, если этот аспект важен для системы.

### Инструменты для тестирования брокеров сообщений:

1. **Apache JMeter** — для нагрузки и стресс-тестирования.
2. **Postman** или **SOAP UI** — для проверки API-интерфейсов брокеров сообщений.
3. **kcat (Kafka Cat)** — для работы с Kafka, чтобы отправлять и получать сообщения.

### Заключение:

Тестирование брокеров сообщений — это комплексный процесс, который требует проверки функциональных аспектов, безопасности, производительности и устойчивости к сбоям. Тестировщики должны учитывать как внутренние (очереди, топики), так и внешние факторы (сеть, конкуренция) для гарантии качественной работы брокеров.

---
#микросервисы
# Микросервисы

**Микросервисная архитектура** - это подход к созданию приложения в виде набора независимо развертываемых сервисов.

### Ключевые характеристики микросервисной архитектуры

- **Одновременная разработка** — благодаря распределенной разработке отдельных частей приложения (то есть микросервисов) можно создавать много микросервисов одновременно, что существенно ускоряет время разработки и позволяет командам быстрее получать рабочую версию приложения.
- **Более четко описываемая архитектура —** если «разукрупнить» крупные приложения на небольшие микросервисы, то многим участникам команд легче понимать их предназначение МС и работать над ними. Преимущество такого «модульного» подхода в том, что он делает имплементацию приложения проще и эффективнее.
- **Повышение отказоустойчивости** — если приложение построено на микросервисной архитектуре, сбой в работе одного микросервиса вряд ли приведет к отказу всего приложения. Поскольку каждый микросервис работает _изолированно_, приложение может оставаться работоспособным, даже если отказали один или несколько связанных микросервисов.
- **Масштабируемость** — если в процессе работы приложения на проде отдельные микросервисы становятся проблемными и/или требуют дополнительных ресурсов, эти микросервисы можно масштабировать и настраивать соответствующим образом. Такие узкие места сложнее устранять в монолитных приложениях.

![[Pasted image 20241106130659.png]]

---
#тестирование_микросервисов #микросервисы
# Тестирование микросервисов

**Микросервисное приложение** — это группа распределенных программ, которые взаимодействуют по сети между собой, а также с third-party-сервисами и базами данных. Микросервисы, в силу своей распределенной природы, дают больше точек отказа, чем традиционный монолит. В связи с этим нужен другой, более широкий подход к тестированию.
### Проблемы при тестировании микросервисов

1. **Распределенность**: микросервисы развертываются на нескольких серверах, возможно расположенных в разных географических точках, что увеличивает задержки и подвергает приложение риску сетевых сбоев. Тесты могут падать не по причине ошибок в коде, а по причине сбоев в сети, что тормозит конвейер CI/CD и блокирует разработку.
	
2. **Автономность**: пока они не нарушают совместимость с API, команды разработчиков могут развертывать свои микросервисы в любое время.
	
3.  **Увеличенная область тестирования**: поскольку каждый микросервис имеет как минимум несколько API-эндпойнтов, нужно охватить гораздо больше тестируемых _поверхностей_.
	
4. **Много языков программирования**: команды разработчиков могут выбирать лучший, по их мнению, язык для своего микросервиса. В большой системе вряд ли удастся найти единый фреймворк, который будет пригоден для тестирования всех компонентов.
	
5. **Production**: поскольку микросервисы развертываются независимо друг от друга и создаются автономными dev-командами, требуются дополнительные проверки, чтобы гарантировать, что все они будут корректно функционировать в связке после развертывания.

**Усредненная версия пирамиды тестирования микросервисов:**

![[Pasted image 20241102181355.png]]

### Основные виды тестирования микросервисов

#### 1. Юнит-тесты

[Модульные тесты](https://testengineer.ru/unit-testirovanie/) — одна из самых трудозатратных форм тестирования, из-за большого количества самих тестов. Юнит состоит из класса, метода или функции, которые должны быть протестированы изолированно.

По сравнению с монолитной системой, в микросервисе гораздо больше шансов у модуля потребовать сетевого вызова для выполнения своей функции. Когда это происходит, мы можем либо позволить коду обратиться к внешнему сервису — смирившись с некоторой задержкой и неопределенностью, — либо заменить вызов [тестовым дублером](https://testengineer.ru/test-doubles/), что дает нам два способа борьбы с зависимостями микросервисов:

- **Одиночные (Solitary)** юнит-тесты: их следует использовать, когда нам нужно, чтобы результат тестирования всегда был _детерминированным,_ то есть определенным. Мы используем [моки и стабы](https://testengineer.ru/mocks-and-stubs/), чтобы изолировать тестируемый код от внешних зависимостей.
- **Общительные (Sociable)** юнит-тесты: общительным тестам разрешено вызывать другие сервисы. В этом режиме мы переносим сложность теста в тестовое или staging-окружение. «Общительные» тесты не являются жестко детерминированными, но мы можем быть более уверены в их результатах, если они прошли.

![[Pasted image 20241102184650.png]]

Моки (Solitary) ускоряют работу и уменьшают неопределенность, но чем больше вы их создаете, тем меньше можете доверять результатам. Sociable-тесты, несмотря на свои недостатки, более реалистичны.

#### 2. Тесты контрактов

Контракт формируется, когда два сервиса связываются через интерфейс. В контракте указываются все возможные входы и выходы, с их структурами данных и возможными побочными эффектами. Потребитель (*consumer*) и провайдер (*producer*) сервиса должны следовать правилам, указанным в контракте, чтобы взаимодействие стало возможным.

Тесты контрактов гарантируют, что микросервисы «соблюдают контракт». Они **не** проверяют поведение сервиса, а лишь гарантируют, что входы и выходы имеют ожидаемые характеристики и что сервис работает в пределах допустимого времени и производительности.

В зависимости от отношений между сервисами, контрактные тесты могут выполняться на стороне провайдера, потребителя, или с двух сторон.

- **Контрактные тесты на стороне consumer** пишутся и выполняются командой _downstream team_. Во время тестирования микросервис подключается к фейк-версии или мок-версии сервиса-producer, чтобы проверить, может ли он использовать его API.
- **Контрактные тесты на стороне producer** выполняются на _upstream_-сервисе. Этот тип тестов эмулирует API-запросы, которые могут выполнять клиенты, проверяя, соответствует ли producer контракту. Тесты на стороне producer позволяют разработчикам проверять совместимость.

![[Pasted image 20241102185046.png]]

- Тесты на стороне *producer* проверяют, что сервис не имплементирует изменений, которые могут нарушить работу связанных сервисов.
- Тесты на стороне *consumer* запускают компонент на стороне потребителя против имитированной версии производителя (не реального провайдера), чтобы убедиться, что потребитель может делать запросы и получать ожидаемые ответы от *producer*

#### 3. Интеграционные тесты

Интеграционные тесты микросервисов работают несколько иначе, чем в других архитектурах. Цель — выявить дефекты интерфейса, заставив микросервисы взаимодействовать. В отличие от контрактных тестов, где одна из сторон имитируется моком, **интеграционные тесты используют реальные сервисы**.

Интеграционные тесты не направлены на оценку поведения или бизнес-логики сервиса. Вместо этого мы хотим убедиться, что микросервисы могут взаимодействовать друг с другом и своими собственными базами данных. 

*@: ищем пропущенные HTTP-заголовки и несовпадение запросов/ответов.* 

Поэтому интеграционные тесты микросервисов обычно реализуются на уровне интерфейса.

![[Pasted image 20241102185739.png]]

#### 4. Компонентные тесты

**Компонент** — это микросервис или набор микросервисов, которые выполняют определенную роль в общей системе.

Тестирование компонентов — это тип *приемочного тестирования*, при котором мы изучаем поведение компонента в изоляции, заменяя сервисы симулированными ресурсами или имитируя их.

Компонентные тесты более подробные чем интеграционные, потому что они проходят _счастливые_ и _несчастливые_ _пути_ — например, как компонент реагирует на симулированные сбои в сети или неправильно сформированные запросы. Мы хотим знать, удовлетворяет ли компонент-сервис потребности своего _потребителя_, как мы это делаем при приемочном или сквозном тестировании.


![[Pasted image 20241102190226.png]]
##### In-process компонентное тестирование

В этом подклассе компонентного тестирования _тест-раннер_ существует в том же потоке или процессе, что и микросервис. Мы запускаем микросервис в «автономном режиме тестирования», где все его зависимости имитируются, что позволяет нам запускать тест без выхода в сеть.

![[Pasted image 20241102190353.png]]

Тест внедряет мок-сервис в адаптер, чтобы имитировать взаимодействие с другими компонентами

In-process-тестирование работает только в том случае, если компонент представляет собой отдельный микросервис.

Единственное отличие компонентного тестирования от *сквозного тестирования* заключается в том, что компонентные тесты выбирают одну часть системы (компонент) и изолируют ее от остальных. Компонент тщательно тестируется, чтобы убедиться, что он выполняет функции, необходимые его пользователям или потребителям.

![[Pasted image 20241102190933.png]]
##### Out-of-process компонентное тестирование

Подходят для компонентов любого размера, включая те, которые состоят из множества микросервисов. При этом типе тестирования компонент развертывается **без изменений** в тестовом окружении, где все внешние зависимости «закрыты» моками или стабами.

![[Pasted image 20241102191132.png]]

#### 5. Сквозное тестирование

Сквозное тестирование **(E2E)** гарантирует, что система отвечает потребностям пользователей и достигает их бизнес-целей. *Тест-сьют* E2E должен охватывать все микросервисы приложения, используя те же интерфейсы, что и пользователи — часто с сочетанием *тестов пользовательского интерфейса* и API.

Приложение должно работать в среде, максимально приближенной к production-среде. В идеале тестовое окружение должно включать все сторонние сервисы, которые нужны приложению; но иногда их можно имитировать моками, чтобы сократить расходы или предотвратить злоупотребления.

![[Pasted image 20241102191957.png]]

Как показано на пирамиде тестирования в начале, тестов E2E меньше всего, и это хорошо, потому что их сложнее всего выполнять и поддерживать. Если мы сосредоточимся на путях пользователя и его потребностях, то сможем извлечь много пользы даже из нескольких E2E-тестов.

[Сурс](https://testengineer.ru/how-to-test-microservices/)
[Нагрузочное тестирование микросервисов](https://testengineer.ru/microservices-load-testing/)

---

Тестирование микросервисов:
    - тестирование запросов к микросервисам
    - тестирование по различным протоколам