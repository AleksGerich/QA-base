---
tags:
  - брокеры
  - брокеры_сообщений
---
---

#брокеры #брокеры_сообщений
# Брокеры сообщений

**Брокеры сообщений (queue brokers)** — это системы для управления и обработки сообщений между приложениями, особенно в [распределенных системах](WEB.md#Распределенные/системы), где важно организовать эффективный обмен данными и обеспечить надежную доставку сообщений. Эти брокеры играют роль посредников, обеспечивая хранение и пересылку сообщений между отправителями и получателями. Примеры таких брокеров включают Apache Kafka, RabbitMQ, ActiveMQ, и другие.

Брокер сообщений представляет собой тип построения архитектуры, при котором элементы системы «общаются» друг с другом с помощью посредника. Благодаря его работе происходит снятие нагрузки с веб-сервисов, так как им не приходится заниматься пересылкой сообщений: всю сопутствующую этому процессу работу он берёт на себя.

![[Pasted image 20241024170932.png]]
### Основные функции брокеров очередей
	
1. **Асинхронное взаимодействие**: Брокеры очередей позволяют приложениям обмениваться сообщениями асинхронно, что уменьшает задержки и разрывы при взаимодействии.
2. **Буферизация сообщений**: Они сохраняют сообщения в очереди, если получатель временно недоступен, и доставляют их позже.
3. **Распределенная обработка**: Брокеры могут распределять сообщения между несколькими потребителями для повышения производительности и масштабируемости.
4. **Долговечность сообщений**: Брокеры очередей гарантируют, что сообщения не будут потеряны в случае сбоев системы.

![[Pasted image 20241024171408.png]]

---
## Producer и consumer

Можно сказать, что в работе любого брокера сообщений используются две основные сущности: **producer** (отвечает за создание сообщений и их отправку в брокер) и **consumer** (отвечает за получение и обработку сообщений)

#### Взаимодействие producer и consumer:
1. **Producer** отправляет сообщение в брокер, который сохраняет его в соответствующей очереди или топике.
2. **Consumer** подписывается на очередь или топик и получает сообщение, когда оно становится доступным.
3. Брокер может управлять количеством consumers, которые будут обрабатывать сообщения параллельно, что повышает производительность и устойчивость системы

## Основные схемы работы брокеров

### 1. Сообщение отправляется напрямую от отправителя к получателю (точка-точка)

Это простая схема, при которой каждое сообщение отправляется от одного отправителя (**producer**) к одному получателю (**consumer**). Сообщения помещаются в очередь, и каждый consumer забирает из неё сообщение по мере обработки. После получения сообщения оно удаляется из очереди.

![[Pasted image 20241024162855.png]]

#### Характеристики:
- **Очередь**: Сообщения отправляются в очередь, и каждый consumer получает уникальное сообщение.
- **Единственный получатель**: Каждое сообщение может быть обработано только одним потребителем.
- **Использование в системах**: Такая схема подходит для систем, где важна точная доставка сообщения одному потребителю, например, обработка банковских транзакций или выполнения заданий на сервере.

#### @:
- **RabbitMQ**: В модели "точка-точка" producer отправляет сообщения в очередь, а consumer забирает их по одному.

К очередям применяется термин «надежные» («durable»). _Надежность_ — это свойство сервиса, которое гарантирует, что система обмена сообщениями будет сохранять сообщения при отсутствии активных подписчиков до тех пор, пока потребитель не подпишется на очередь для доставки сообщений.

Надежность часто путают с _персистентностью_ и, хотя эти два термина взаимозаменяемы, они выполняют разные функции:
- **Персистентность** определяет, записывает ли сообщение система обмена сообщениями в какого-либо рода хранилище между получением и отправкой его потребителю (не обязательно)

### 2. Схема публикации/подписки (Publish/Subscribe)

В этой схеме один отправитель может публиковать сообщения для нескольких подписчиков. Producer публикует сообщение в **топик** (в Kafka) или **обменник** (в RabbitMQ), а затем несколько consumers, подписанные на этот топик, получают это сообщение. Важно, что одно и то же сообщение может быть получено несколькими получателями одновременно.

В классических системах обмена сообщениями модель обмена сообщениями «публикация-подписка» реализуется через _топики_. Топик предоставляет такой же способ широковещания, как и механизм конференц-связи. Когда сообщение отправляется в топик, оно распределяется _по всем подписанным пользователям_.

Топики обычно _ненадежные (nondurable)_. Как и слушатель, который не слышит, что говорится на конференц-звонке, когда слушатель отключается, подписчики топика пропускают любые сообщения, которые отправляются в тот момент, когда они находятся в автономном режиме. По этой причине можно сказать, что топики предоставляют гарантию доставки _не более одного раза_ для каждого потребителя

![[Pasted image 20241024163421.png]]

#### Характеристики:
- **Топики**: Сообщения отправляются в топик или обменник, и все подписчики этого топика получают сообщение.
- **Несколько получателей**: Одно сообщение может быть отправлено нескольким потребителям.
- **Использование в системах**: Такая схема используется, когда сообщение должно быть обработано несколькими службами одновременно, например, система уведомлений или рассылка данных для аналитики в реальном времени.

#### @:
- **Kafka**: В модели "Publish/Subscribe" producer публикует сообщение в топик, а несколько consumers, подписанные на этот топик, могут его получить.

Обмен сообщениями типа «публикация-подписка» обычно используется, когда сообщения носят информационный характер, и потеря одного сообщения — не особо значима. Например, топик может передавать показания температуры от группы датчиков один раз в секунду. Система, которая интересуется текущей температурой и которая подписывается на топик, не будет переживать, если она пропустит сообщение — другое поступит в ближайшее время.

### 3. Гибридная схема

Сценарии использования часто требуют совмещения моделей обмена сообщениями «публикация-подписка» и «точка-точка», например, когда нескольким системам требуется копия сообщения, и для предотвращения потери сообщения требуется как надежность, так и персистентность.  
  
В этих случаях требуется адресат (destination) (общий термин для очередей и топиков), который распределяет сообщения в основном как топик, так, что каждое сообщение отправляется в отдельную систему, заинтересованную в этих сообщениях, но и также в которой каждая система может определить несколько потребителей, которые получают входящие сообщения, что больше похоже на очередь. Тип чтения в этом случае — _один раз для каждой заинтересованной стороны_. 

Гибридные адресаты часто требуют надежности (durability), так что, если потребитель отключается, сообщения, которые отправляются в это время, принимаются после повторного подключения потребителя.  
  
Гибридные модели не новы и могут применяться в большинстве систем обмена сообщениями, включая как ActiveMQ (через виртуальные или составные адресаты, которые объединяют топики и очереди), так и Kafka (неявно, как фундаментальное свойство дизайна её адресата).  
  
Теперь, когда у нас есть некоторая базовая терминология и понимание того, для чего нам могла бы пригодиться система обмена сообщениями, давайте перейдем к деталям.

#### @:
Веб-сайт магазина помещает сообщения о заказах в «очередь сообщений». Основным потребителем этих сообщений является исполнительная система. Кроме того, система аудита должна иметь копии этих сообщений о заказах для последующего отслеживания. Обе системы не могут пропускать сообщения, даже если сами системы в течение некоторого времени недоступны. Веб-сайт не должен знать о других системах.

---
## Когда использовать

1. Если в рамках системы есть действия, которые требуют для своего выполнения **много времени и потребляют много ресурсов**, при этом они не требуют немедленного результата.

2. **Микросервисы**. если ваша система достаточно сложна и состоит из отдельных сервисов, то для их координации можно использовать брокер сообщений, который в этом случае будет выступать в роли как бы центрального роутера. Каждый сервис подписывается только на свой тип сообщений, выстраивается определённая логика их обработки.

3. **Мобильные приложения**. здесь возможен вариант с задействованием push-уведомлений, когда множество смартфонов с установленным приложением подписаны на определённую тему. Если в ней публикуется какая-либо новость, то подписанный смартфон выводит уведомление.

4. **Транзакционные системы.** если какое-то действие системы состоит из множества отдельных этапов, каждый из которых выполняется отдельным элементом системы, то в этом случае брокер сообщений может выступить в роли своеобразной «доски уведомлений». Каждый сервис отписывается после того, как его этап общей задачи был выполнен. После этого в работу вступает следующий сервис, обрабатывающий, соответственно, следующий этап общей задачи.

![[Pasted image 20241024171711.png]]
#### Недостатки брокеров сообщений:
	
1.  **Усложнение системы** в целом как таковой, так как в ней появляется ещё один элемент. Кроме того, возникает зависимость от надёжности распределённой сети, а также потенциальная возможность возникновения проблем из-за потребности в непротиворечивости данных, так как некоторые элементы системы могут обладать неактуальными данными.
	
2. Из-за асинхронной работы всей системы, а также её распределённого характера могут **возникать ошибки**, выяснение сути которых может стать непростой задачей.
	
3. **Освоение** подобных систем является не самым простым вопросом и может занять существенное время.

### Примеры использования брокеров сообщений:

1. **Обработка заказов в интернет-магазине**: Сообщения о заказах могут отправляться через брокер очередей для асинхронной обработки — проверки оплаты, подготовки к отправке и т.д.
2. **Аналитика в реальном времени**: Системы потоковой аналитики используют брокеров сообщений для передачи данных от датчиков или других источников.
3. **Микросервисная архитектура**: Брокеры помогают организовать взаимодействие между микросервисами, обеспечивая независимость и асинхронность.

[Сурс из сбера](https://habr.com/ru/companies/sberbank/articles/669456/)

---
#брокеры #брокеры_очередей #kafka
# Apache Kafka

**Apache Kafka** — это один из самых популярных брокеров сообщений, разработанный для обработки потоков данных в режиме реального времени. В отличие от традиционных систем очередей сообщений, Kafka ориентирован на массовую обработку потоков событий с высокой пропускной способностью.

Apache Kafka представляет собой брокер, который, в отличие от RabbitMQ, хранит все сообщения в виде распределённого лога, причём гарантируется, что порядок сообщений отражает последовательность их поступления в систему. Сообщение в этом логе хранится в течение определённого времени, и работа построена таким образом, что продюсеры пишут новые сообщения в систему, а подписчики сами их запрашивают. При надобности организуется хранение сообщений в рамках тем. То есть можно сказать, что происходит определённого рода группировка сообщений в рамках одной темы.

Apache Kafka больше предназначен для построения высоконагруженных систем сферы bigdata, так как сама его парадигма параллельной обработки, репликации позволяет создавать достаточно надёжные системы и обеспечивать неограниченные возможности по масштабированию. Высокая пропускная способность, а также возможности извлечения сообщений из очереди за определённый период времени (так как они хранятся в очереди, как мы сказали ранее, именно в том порядке, в каком были отправлены) являются мощным инструментом для анализа происходящего в историческом разрезе.

### Основные особенности:

1. **Событийная архитектура**: Kafka работает по принципу логов, где сообщения сохраняются в виде непрерывных потоков событий.
2. **Топики (Topics)**: Сообщения организованы в топики — логические каналы для передачи данных.
3. **Продюсеры и консюмеры**: Продюсеры отправляют сообщения в топики, а консюмеры подписываются на них для получения сообщений.
4. **Масштабируемость**: Kafka может работать в кластере с горизонтальным масштабированием, что делает его подходящим для больших объемов данных.

**Использование Kafka**: Kafka применяется для построения событийно-ориентированных архитектур, потоковой аналитики, логгирования данных и интеграции микросервисов. Это делает его идеальным для систем, работающих с большими объемами данных в реальном времени.

---
#брокеры #брокеры_очередей #rabbitmq #rabbit
# RabbitMQ

**RabbitMQ** — это еще один популярный брокер очередей, который чаще используется в традиционных системах обмена сообщениями.

RabbitMQ позволяет сконфигурировать даже весьма сложные сценарии доставки сообщений, что даёт разработчикам гибкость в построении нужного сценария информирования о событиях. При этом следует учитывать, что порядок доставки сообщений не гарантируется.

### Основные особенности:

1. **Очереди**: Сообщения организованы в очереди, и они передаются между продюсерами и консюмерами.
2. **Маршрутизация сообщений**: RabbitMQ предлагает расширенные механизмы маршрутизации сообщений через обменники (exchanges) и ключи маршрутизации.
3. **Поддержка различных протоколов**: RabbitMQ поддерживает AMQP, MQTT и другие протоколы для работы с различными типами систем.

**Использование RabbitMQ**: Он широко применяется для интеграции микросервисов, задач асинхронной обработки данных, а также в системах, где важна надежная доставка сообщений.

### Отличия Kafka и RabbitMQ:

- **Архитектура**: Kafka использует модель публикации-подписки с логом, а RabbitMQ — классическую модель очередей с продюсерами и консюмерами.
- **Пропускная способность**: Kafka подходит для высоких объемов данных и потоков событий, тогда как RabbitMQ лучше для задач с низкой задержкой и точной доставкой сообщений.
- **Масштабируемость**: Kafka лучше масштабируется горизонтально за счет распределенной архитектуры.

### Различия в подходах Kafka и RabbitMQ:

- **Kafka** использует модель публикации-подписки, где consumers подписываются на топики, а сообщения хранятся в журнале (log) до тех пор, пока они не будут прочитаны.
- **RabbitMQ** реализует классическую модель очередей, где сообщения направляются конкретным consumers через маршрутизацию (routing).

---
#тестирование_брокеров #брокеры #брокеры_очередей 
# Тестирование брокеров очередей

Тестирование брокеров сообщений, таких как **Apache Kafka** или **RabbitMQ**, требует комплексного подхода, поскольку брокеры обеспечивают асинхронное взаимодействие между сервисами и масштабируемую передачу данных. Для тестировщика задача состоит в проверке корректности работы передачи сообщений, управления очередями, а также соблюдения гарантий доставки сообщений. Вот основные шаги и методы, которые помогут протестировать брокеры:

### 1. **Функциональное тестирование**

Основной задачей здесь является проверка того, что сообщения корректно передаются между producer и consumer. Тестировщик проверяет:

- Может ли **producer** отправлять сообщения в очередь/топик.
- Может ли **consumer** получать эти сообщения.
- Корректно ли сообщения удаляются из очереди после получения.

#### @:
- Отправка тестового сообщения и проверка, что оно было доставлено конкретному consumer.
*python*
`# Проверка отправки и получения сообщения 
producer.send('test_topic', value={'key': 'value'}) 
message = consumer.poll(timeout_ms=1000)  
assert message is not None assert message.value == {'key': 'value'}`

### 2. **Тестирование устойчивости (Failover testing)**

Это тестирование направлено на проверку поведения брокера в условиях отказов. Брокер должен корректно восстанавливаться после сбоев и продолжать доставку сообщений. Тестировщик может:

- Проверить, что произойдет, если **consumer** или **producer** упадет в середине процесса.
- Убедиться, что сообщения не теряются и остаются в очереди до тех пор, пока не будут обработаны.

Пример сценария:

1. Остановить consumer и отправить несколько сообщений от producer.
2. Запустить consumer и проверить, что он получил все сообщения после перезапуска.

### 3. **Тестирование производительности**

Цель — убедиться, что брокер может обрабатывать большой объем сообщений без снижения производительности. Тестировщик должен:

- Измерять скорость передачи сообщений (throughput).
- Проверять задержку доставки (latency) при разных нагрузках.
- Определять, как брокер обрабатывает ситуацию, когда очередь переполнена.

**Пример инструмента**: Для Kafka можно использовать утилиты, такие как **kafka-producer-perf-test.sh** и **kafka-consumer-perf-test.sh**, чтобы измерить производительность.

### 4. **Тестирование конфигурации и безопасности**

Тестировщик проверяет настройки прав доступа, шифрования сообщений и изоляции данных. Это важно для обеспечения безопасности в производственной среде.

- **Аутентификация**: Проверить, что только авторизованные пользователи могут отправлять или получать сообщения.
- **Шифрование**: Проверить, что сообщения передаются по зашифрованным каналам.

### 5. **Тестирование конкуренции (Concurrency testing)**

Брокеры сообщений часто работают в многопоточном режиме, и важно проверить, что они корректно обрабатывают большое количество параллельных подключений.

- Запуск нескольких **producer** и **consumer** одновременно.
- Проверка корректности обработки сообщений при высокой конкуренции за доступ к очередям.

### 6. **Тестирование с задержкой и повторной попыткой (Retry/Backoff testing)**

Тестировщик должен проверить, как брокер обрабатывает повторные попытки доставки сообщений при временных сбоях.

- Если consumer временно недоступен, брокер должен сохранить сообщение для повторной доставки.

### 7. **Тестирование дедупликации сообщений**

Некоторые системы могут отправлять дубликаты сообщений. Тестировщик должен проверить, что:

- Сообщения доставляются только один раз (idempotent delivery).
- Сообщения не дублируются, если этот аспект важен для системы.

### Инструменты для тестирования брокеров сообщений:

1. **Apache JMeter** — для нагрузки и стресс-тестирования.
2. **Postman** или **SOAP UI** — для проверки API-интерфейсов брокеров сообщений.
3. **kcat (Kafka Cat)** — для работы с Kafka, чтобы отправлять и получать сообщения.

### Заключение:

Тестирование брокеров сообщений — это комплексный процесс, который требует проверки функциональных аспектов, безопасности, производительности и устойчивости к сбоям. Тестировщики должны учитывать как внутренние (очереди, топики), так и внешние факторы (сеть, конкуренция) для гарантии качественной работы брокеров.

---

Тестирование микросервисов:
    - тестирование запросов к микросервисам
    - тестирование по различным протоколам