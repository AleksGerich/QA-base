---
tags:
  - теория_по_git
  - команды_git
---
 
---
#теория_по_git
# Теоретические аспекты

К базовым возможностям Git относятся:

- Возврат к любой прошлой версии кода
- Просмотр истории изменений
- Восстановление любых данных
- Совместная работа без риска потерять данные или перезаписать чужую работу

### Индексирование и добавление в репозиторий файлов

Индексы присваиваются файлам (*add*) для последующего добавления в коммит

Процесс создания и добавления файлов в репозиторий git:

![[Pasted image 20241106151709.png]]

Почему используется длительный процесс добавления файлов в репозиторий:
- в случае, если нет необходимости вносить все файлы в один коммит
- атомарность коммита - выполнение только одной задачи

---
### SSH-ключ

Текущий ssh-ключ по пути: */home/user/.ssh/id_ed25519*

[Инструкция по созданию SSH ключей в GitHub](https://github.com/Hexlet/ru-instructions/blob/main/git.md)

---
### Общий вид git-системы

Git — это **распределенная система контроля версий**. Это значит, что у Git нет какого-то центрального места, где лежит один главный репозиторий, а разработчики работают с ним со своих компьютеров

![[Pasted image 20241106160517.png]]

---
### Коммиты

Характеристика коммита:
- хронит снимок всх файлов внутри директории
- не просто копирует всю директорию каждый раз, а ужимает коммит в набор изменений (дельта между текущей и предыдущей версией)
- коммит уходит в историю о том, когда какой коммит был сделан (поэтому есть поддержка истории коммитов)
- у каждого коммита (кроме начального) есть "родитель" (C1), который указывает на предыдущий коммит

![[Pasted image 20241107131148.png]]

---
### Ветки (branch)

**branch** - представляет собой ссылку на определенный коммит

![[Pasted image 20241107131315.png]]
- *git branch newImage*

![[Pasted image 20241107131419.png]]
- *git commit*

При создании нового коммита (C2) ссылкой на C2 будет текущая выбранная ветка (в данном случае main)

![[Pasted image 20241107131554.png]]
- *git checkout newImage; git commit*

Для создания коммита под выбранной веткой необходимо на нее переключиться

---
### Слияние веток (merge)

Алгоритм хорошего человека:
1. Создание своей ветки
2. Сделать на ней работу 
3. Слить с общей веткой

Один из способов - **git merge**.
- вид коммита, имеющий сразу двух родителей

*@:*
Вот у нас две ветки, каждая содержит по одному уникальному коммиту. Указатель находится на ветке main:

![[Pasted image 20241107131752.png]]

![[Pasted image 20241107131840.png]]
- *git merge bugFix*

- C4 теперь имеет двух родителей (C2, C3)
- Теперь в ветке main содержатся все изменения в репозитории
- По каждому из родителей можно пройти к C0
- К C4 привязана выбранная в момент merge ветка (main)

Чтобы сдвинуть ветку *bugFix* к C4 нужно переключиться на *bugFix* и замержить ее с веткой main

![[Pasted image 20241107132133.png]]
- *git checkout bugFix; git merge main*

Т.к. ветка bugFix была предшественницей main, Git не делал ничего, только сдвинул bugFix на тот же коммит, где находится main

---
#команды_git
# Инициализация репозитория

#### git init
- инициализация git репозитория в текущей директории - директория *.git*
- *.git* содержит все необходимые для работы Git-файлы

#### git config --global [название настройки]
- редактирование параметров репозитория
- *--global* - данные настройки будут применены абсолютно к любым файлам
	
#### git config --global user.name "[имя]"
- Установление имя пользователя, который будет вносить изменения в файлы
	
#### git config --global user.email "[почта]"
- Установление почты пользователя

#### git status
- исполняется в созданном репозитории
- выводит статус репозитория

#### git diff
- показывает различия между изменениями файлов в текущей ветке (еще не закоммиченных)
- содержит не файлы целиком, а именно те строки, которые изменились
- Слева от строк ставится:
	- Знак `-`, если строка была удалена
	- Знак `+`, если строка была добавлена
- команда также запускает [пейджер](https://ru.hexlet.io/courses/cli-basics/lessons/read-files/theory_unit) — специальную программу, которая позволяет перемещаться по выводу и искать внутри него нужные данные
	- **f** — перемещение вниз
	- **b или u** — перемещение вверх
	- **q** — или выход из режима просмотра

#### git diff --staged
- показывает изменения в индексированных файлах (*add*)

---
# Игнорирование файлов в директории

#### .gitignore
- файл, который создается в корне репозитория (желательно)
	- может создаваться в разных директориях репозитория
- в нем явным образом прописываются файлы, которые не должны быть проиндексированны при коммите
- пушится в удаленный репозиторий вместе со всеми файлами (.gitignore становится доступным для всех)

#### .git/info/exclude
- определяет персональный шаблон игнорирования конкретного репозитория
	@: прописываются личные файлы чтобы никто не увидел
- сюда тоже явным образом прописываются файлы для игнорирования
- не имеет контроля версии и не будет пушится в удаленный репозиторий

#### git rm --cached \[имя файла]
- игнорирование ранее закоммиченного файла
- удаляет файл из репозитория, но оставляет в рабочей директории

---
# Добавление файлов в репозиторий

***Шаг 1***
#### git add \[название файла]
- команда подготовки файлов перед добавлением
- т.е. файл попал в **индекс**
- в статусе файл переходит в состояние *"Changes to be commited"*

#### git add .
- индексирует все файлы в выбранной директории

***Шаг 2***
#### git commit
- окончательное добавления файла в репозиторий
- без описания коммита откроется редактор, где записывается описание (подходит для длинного описания)
- коммит файлов производится не только при создании и изменении файлов, но и при их удалении (**любое изменение файлов = комит**)

#### git commit -m '\[описание коммита]'
- **-m** - дает возможность присвоить произвольное описание коммита
- редактор не будет открыватсья

# Удаление файлов
#### git rm \[имя файла]
- удаляет указанный файл
- затем подготавливает это событие к коммиту (вместо прописывания add отдельно)

#### git rm --cached \[имя файла]
- убирает возможность отслеживать индекс файла для коммита (файл будет игнорироваться *add*)
- также подходит для игнорирования ранее закомиченного файла
- удаляет файл из репозитория, но оставляет в рабочей директории

#### git restore \[имя файла]
- восстанавливает удаленный файл в локальном репозитории
- удаленный файл должен быть закоммиченным
- также может откатить изменения в незакоммиченном выбранном файле (при условии существовании версии отката в коммите)

---
# Подключение к GitHub

#### git remote add \[origin] git@github.com:\[имя на gitHub]/\[имя репозитория].git
- создается подключение локального репозитория Git и удаленного GitHub
- ссылку можно взять из репозитория GitHub

---
# Пуш в GitHub

#### git push -u \[origin] \[ветка откуда пушится]
- отправляет изменения директории на GitHub репозиторий

#### git push
- тоже самое, при уже установленном подключении с внешней директорией

---
# Клонирование репозитория (pull)

#### git clone git@github.com:\[имя на gitHub]/\[имя репозитория].git
- пул выбранного репозитория к себе на машину
- если репозиторий публичный - любой сможет запулить (но не запушить изменения на gitHub)

#### git clone ./\[клонируемый репозиторий] \[куда клонировать]
- клонирование локального репозитория в указанную директорию (пустую папку) - тоже локально
- указанная директория может не существовать, тогда клон создастся по указанному пути (сам создаст)
- по сути - копирование репозитория

#### git pull
- скачивание всех изменений (коммитов) с репозитория gitHub
- ведет к созданию ненужных коммитов (сложнее следить за историей изменений)
- нужен развернутый локальный репозиторий

#### git pull --rebase
- скачивает из внешнего репозитория новые коммиты и добавляет их в локальный 

#### git pull --rebase origin \[название основной ветки]
- Перенесет локальные коммиты на вершину удаленных, сохраняя линейную историю
- переносит в указанную ветку

---
# Ветвление

#### git branch
- выводит весь список веток на коммите

#### git branch \[название ветки]
- создает новую ветку на текущем коммите с указанным названием
- текущая ветка остается прежней (не переключается на новую)

#### git branch -M \[новое название ветки]
- переименовывает текущую ветку на выбранное название

#### git checkout \[название ветки]
- переключает с текущей ветки на выбранную
- может переключаться даже, если ветка расположена вне текущего коммита

#### git checkout -b \[название ветки]
- создает новую ветку на текущем коммите с указанным именем

---
# Слияние веток

#### git merge \[ветка с которой проводится слияние]
- вливает в текущую ветку изменения (различия в коммитах) выбранной ветки
- сохраняет полную историю и хронологический порядок обеих веток
	- история коммитов может быть "загрязнена" избытком

#### git merge \[ветка откуда] \[ветка куда]
- альтернативный метод merge без необходимости переключения на ветку
- основная ветка будет \[ветка куда]

![[Pasted image 20241114134812.png]]
```
$ git merge master feature
```
#### git rebase \[ветка, куда проводится слияние]
- вливает текущую ветку в выбранную
- все изменения выбранной ветки сжимаются в "патч", который интегрируется в текущую ветку
- перезаписывает историю коммитов текущей ветки, потому что она передает завершенную работу из одной ветки в другую
- очищает промежуточные коммиты, делая их одним коммитом
- для восстановления с удаленными ветками требуется принудительный пуш. Это приводит к обновлению всех веток, имеющих одно и то же имя, как локально, так и удаленно, и это ужасно.

![[Pasted image 20241114134658.png]]
```
$ git checkout feature
$ git rebase master
```

#### git rebase -i \[ветка, куда вливаются изменения]
- интерактивный режим - позволяет изменять коммиты при их перемещении в новую ветку
- обеспечивает полный контроль над историей коммитов
- как правило, используется для очистки истории до слияния ветки feature в master
- точно определяет, как будет выглядеть ветка после выполнения перемещения

вид редактора:
![[Pasted image 20241114135821.png]]

---
# Анализ истории изменений

#### git log
- показывает список всех выполненных коммитов, отсортированных по дате добавления

#### git log -p
- показывает полный лог изменений файлов (как diff)
- Промотать вперед — кнопка **f**, промотать назад — **b**
- Выйти из режима просмотра — **q**

#### git show \[хеш выбранного коммита]
- показывает все изменений только в выбранном коммите (в отличие от *git log -p*)
- можно обойтись только первыми символами хеша (7 символов)
- хеш коммита можно посмотреть в *git log*

#### git blame \[путь до файла]
- показывает все строки файла, а также кто какую менял и в каком коммите
- изменение строчки — не то же самое, что ее написание. Возможно, что программист исправил небольшую опечатку, а саму строчку написал кто-то до него.

#### git grep \[искомая строка (или часть строки)]
- ищет совпадения с указанной строкой во всех файлах проекта
- возвращает файл и указанное слово
- не смотрит в .git
- знает про игнорирование (поэтому лучше линуксовой)

#### git grep -i \[искомая строка]
- поиск без учета регистра

#### git grep \[искомая строка] \[хеш коммита]
- поиск строки в указанном коммите

#### git grep \[искомая строка] $(git rev-list --all)
- поиск указанной строки во всей истории коммитов
- возвращает хеш коммита, название файла и искомое слово

