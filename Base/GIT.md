---
tags:
  - теория_по_git
  - команды_git
---

---
#теория_по_git
# Теоретические аспекты

К базовым возможностям Git относятся:

- Возврат к любой прошлой версии кода
- Просмотр истории изменений
- Восстановление любых данных
- Совместная работа без риска потерять данные или перезаписать чужую работу

### Индексирование и добавление в репозиторий файлов

Индексы присваиваются файлам (*add*) для последующего добавления в коммит

Процесс создания и добавления файлов в репозиторий git:

![[Pasted image 20241106151709.png]]

Почему используется длительный процесс добавления файлов в репозиторий:
- в случае, если нет необходимости вносить все файлы в один коммит
- атомарность коммита - выполнение только одной задачи

---
### SSH-ключ

Текущий ssh-ключ по пути: */home/user/.ssh/id_ed25519*

*ssh-private-key:*
b3BlbnNzaC1rZXktdjEAAAAABG5vbmUAAAAEbm9uZQAAAAAAAAABAAAAMwAAAAtzc2gtZW
QyNTUxOQAAACBl2pyAoSJPcPVzi+C1tJvDhhMvuLBJG4xa9q3wpgczzQAAAJi5xn1JucZ9
SQAAAAtzc2gtZWQyNTUxOQAAACBl2pyAoSJPcPVzi+C1tJvDhhMvuLBJG4xa9q3wpgczzQ
AAAEAOw7B63JxSzutavYvNjv6A0sHNak7ejxbpW80XPxd3B2XanIChIk9w9XOL4LW0m8OG
Ey+4sEkbjFr2rfCmBzPNAAAAFGEuc21pcm5vdjMzM0BtYWlsLnJ1AQ==

*ssh-public-key:*
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIGXanIChIk9w9XOL4LW0m8OGEy+4sEkbjFr2rfCmBzPN a.smirnov333@mail.ru

*The key fingerprint is:*
SHA256:90Eon1rvFDetYCoWqSvWUKEZdhClEVv55qzDWeLP1aQ a.smirnov333@mail.ru

*The key's randomart image is:*
+--[ED25519 256]--+
|    ==o.         |
|    o=+    .     |
|   .o= o. . .    |
|    o . o+ o   . |
|     . +S = * o .|
|    . ..+= O = o |
|     =.=+ E = .  |
|    o B+ o o     |
|   . ..oo   .    |
+----[SHA256]-----+


[Инструкция по созданию SSH ключей в GitHub](https://github.com/Hexlet/ru-instructions/blob/main/git.md)

---
### Общий вид git-системы

Git — это **распределенная система контроля версий**. Это значит, что у Git нет какого-то центрального места, где лежит один главный репозиторий, а разработчики работают с ним со своих компьютеров

![[Pasted image 20241106160517.png]]

---
### Коммиты

Характеристика коммита:
- хронит снимок всх файлов внутри директории
- не просто копирует всю директорию каждый раз, а ужимает коммит в набор изменений (дельта между текущей и предыдущей версией)
- коммит уходит в историю о том, когда какой коммит был сделан (поэтому есть поддержка истории коммитов)
- у каждого коммита (кроме начального) есть "родитель" (C1), который указывает на предыдущий коммит

![[Pasted image 20241107131148.png]]

---
### Ветки (branch)

**branch** - представляет собой ссылку на определенный коммит

![[Pasted image 20241107131315.png]]
- *git branch newImage*

![[Pasted image 20241107131419.png]]
- *git commit*

При создании нового коммита (C2) ссылкой на C2 будет текущая выбранная ветка (в данном случае main)

![[Pasted image 20241107131554.png]]
- *git checkout newImage; git commit*

Для создания коммита под выбранной веткой необходимо на нее переключиться

---
### Слияние веток (merge)

Алгоритм хорошего человека:
1. Создание своей ветки
2. Сделать на ней работу 
3. Слить с общей веткой

Один из способов - **git merge**.
- вид коммита, имеющий сразу двух родителей

*@:*
Вот у нас две ветки, каждая содержит по одному уникальному коммиту. Указатель находится на ветке main:

![[Pasted image 20241107131752.png]]

![[Pasted image 20241107131840.png]]
- *git merge bugFix*

- C4 теперь имеет двух родителей (C2, C3)
- Теперь в ветке main содержатся все изменения в репозитории
- По каждому из родителей можно пройти к C0
- К C4 привязана выбранная в момент merge ветка (main)

Чтобы сдвинуть ветку *bugFix* к C4 нужно переключиться на *bugFix* и замержить ее с веткой main

![[Pasted image 20241107132133.png]]
- *git checkout bugFix; git merge main*

Т.к. ветка bugFix была предшественницей main, Git не делал ничего, только сдвинул bugFix на тот же коммит, где находится main

---
#команды_git
# Инициализация репозитория

#### git init
- инициализация git репозитория в текущей директории - директория *.git*
- *.git* содержит все необходимые для работы Git-файлы

#### git status
- исполняется в созданном репозитории
- выводит статус репозитория

---
# Добавление файлов в репозиторий

***Шаг 1***
#### git add \[название файла]
- команда подготовки файлов перед добавлением
- т.е. файл попал в **индекс**
- в статусе файл переходит в состояние *"Changes to be commited"*

#### git add .
- индексирует все файлы в выбранной директории

***Шаг 2***
#### git commit
- окончательное добавления файла в репозиторий
- без описания коммита откроется редактор, где записывается описание (подходит для длинного описания)
- коммит файлов производится не только при создании и изменении файлов, но и при их удалении (**любое изменение файлов = комит**)

#### git commit -m '\[описание коммита]'
- **-m** - дает возможность присвоить произвольное описание коммита
- редактор не будет открыватсья

# Удаление файлов
#### git rm \[имя файла]
- удаляет указанный файл
- затем подготавливает это событие к коммиту (вместо прописывания add отдельно)

#### git restore \[имя файла]
- восстанавливает удаленный файл в локальном репозитории
- удаленный файл должен быть закоммиченным

---
# Подключение к GitHub

#### git remote add \[origin] git@github.com:\[имя на gitHub]/\[имя репозитория].git
- создается подключение локального репозитория Git и удаленного GitHub

---
# Пуш в GitHub

#### git push -u \[origin] \[ветка откуда пушится]
- отправляет изменения директории на GitHub репозиторий

#### git push
- тоже самое, при уже установленном подключении с внешней директорией

---
# Клонирование репозитория (pull)

#### git clone git@github.com:\[имя на gitHub]/\[имя репозитория].git
- пул выбранного репозитория к себе на машину
- если репозиторий публичный - любой сможет запулить (но не запушить изменения на gitHub)

#### git clone ./\[клонируемый репозиторий] \[куда клонировать]
- клонирование локального репозитория в указанную директорию (пустую папку) - тоже локально
- указанная директория может не существовать, тогда клон создастся по указанному пути (сам создаст)
- по сути - копирование репозитория

#### git pull
- скачивание всех изменений (коммитов) с репозитория gitHub
- ведет к созданию ненужных коммитов (сложнее следить за историей изменений)
- нужен развернутый локальный репозиторий

#### git pull --rebase
- скачивает из внешнего репозитория новые коммиты и добавляет их в локальный 

---
# Ветвление

#### git branch
- выводит весь список веток на коммите

#### git branch \[название ветки]
- создает новую ветку на текущем коммите с указанным названием
- текущая ветка остается прежней (не переключается на новую)

#### git branch -M \[новое название ветки]
- переименовывает текущую ветку на выбранное название

#### git checkout \[название ветки]
- переключает с текущей ветки на выбранную
- может переключаться даже, если ветка расположена вне текущего коммита

#### git checkout -b \[название ветки]
- создает новую ветку на текущем коммите с указанным именем

---
# Слияние веток

#### git merge \[ветка с которой проводится слияние]
- вливает в текущую ветку изменения (различия в коммитах) выбранной ветки

