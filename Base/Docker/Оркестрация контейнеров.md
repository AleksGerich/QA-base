

Большинство микросервисов — это контейнеры, которые должны связно работать между собой. Кроме контейнеров, это могут быть обычные приложения: например, на Java или виртуальной машине. Оркестратор позволяет управлять всем этим централизованно.

## Что должно быть в оркестраторе

1. ***Возможность быстро начать работать***
	- чтобы не тратить полгода на изучение и тестирование
	
2. ***Набор определенных возможностей из коробки***
	- **управление секретами** — передавать приложению пароли, токены, доступы к БД, а не хранить все в коде
	- **service discovery** — подключать новые реплики приложения к инфраструктуре
	- **возможности кастомизации кластера** — для добавления своих сущностей и организации API для наших целей
	
3. ***Наименьший vendor lock-in***
	- когда разработчики завязывают покупателя на конкретную технологию, и переход от одного поставщика к другому сопровождается большими сложностями
	
4. ***Горизонтальное масштабирование***
	- увеличение узлов кластера приложения при возросшей нагрузке
	
5. ***Вертикальное масштабирование***
	- управление ресурсами (памятью, ядра процессора...) приложения
	
6. ***Разные стратегии обновления приложения***
	- Приоритет: незаметно для пользователя и бизнеса
	
7. ***Инфраструктура как код (IaC)***
	- удобная вещь, позволяющая хранить состояния приложения, описанные кодом, в манифестах. Удобно для инженеров и новичков. Когда в компанию приходит новичок, ему очень просто познакомиться с инфраструктурой и понять, где, что и как настроено. Все это удобно версионируется. Шаблонизация нужна, чтобы переиспользовать манифесты и не писать каждый раз одинаково. 
	- *@:* мы подставляем разные значения в заготовленные шаблоны и меняем версии приложения.
	
8. ***Крупное сообщество***
	- залог жизни технологии и разнообразия инструментов. Пока есть сообщество - есть технология.


## Горизонтальное маштабирование

![[Pasted image 20241130182753.png]]

**Горизонтальное масштабирование** - автоматическое масштабирование узлов кластера и приложения. Нагрузка может быть нелинейной, поэтому оркестратор должен уметь увеличить количество реплик приложения в процессе работы. Если в кластере не хватает ресурсов, нужно соответственное увеличение количества узлов кластера
## Вертикальное масштабирование

![[Pasted image 20241130182922.png]]

**Вертикальное масштабирование** - кластер управляет ресурсами, которые выделяются приложению. Выделять и ограничивать ресурсы необходимо, чтобы не столкнуться с такими ситуациями, когда одно из приложений съело всю память и CPU на наших серверах, а другим ничего не осталось. Оркестратор понимает, какие лимиты ресурсов есть у приложения на старте, и до каких оно может подниматься.

## Стратегии обновления приложения

Приложения постоянно обновляются. Чтобы это проходило незаметно для пользователя и бизнеса, а сами обновления не ломались в процессе, оркестраторы имеют для этого разные стратегии обновлений

![[Pasted image 20241130183401.png]]

***Rolling*** — новая версия приложения выкатывается постепенно. 
- *@:* у нас есть 5 реплик приложения, которые постепенно заменяют исходное, пока, наконец, версия полностью не заменится на новую.

***Recreate*** — достаточно простая стратегия, когда мы просто убиваем старую версию и раскатываем новую 
- Самая неэффективная стратегия, так как программный продукт – будет в простое (будет недоступен в момент обновления)

***Blue/Green*** — мы выкатываем на стенды сразу 2 версии приложения: пока одна работает, вторая тестируется и со временем заменяет первую.

***Canary (Dark)*** — достаточно похожа на Blue/Green, но с одной особенностью. Новая версия сначала выкатывается для ограниченного числа пользователей. В случае отсутствия проблем мы постепенно заменяем на новую версию все приложение.

---
# Виды оркестраторов

## Docker Swarm

Docker Swarm состоит из менеджеров и воркеров. Менеджеры определяют, на каких воркерах и как будут работать контейнеры, и хранят стек нашего кластера. Контейнер крутится на воркерах. 

![[Pasted image 20241130183909.png]]

Минимальная рабочая сущность Docker — Service, который разбивается на task, в каждом из которых — Docker-контейнер.

![[Pasted image 20241130184021.png]]

#### Плюсы
- Бесплатный
- Нетребовательный к ресурсам
- Низкий порог входа

#### Минусы
- Работает только с докер контейнерами
- Не поддерживает автоматическое масштабирование
- Малая поддержка сообщества
- Стратегия обновления только Rolling Update
- Нет встроенной поддержки шаблонов

---
## Nomad

Состоит из серверов, которые определяют, где и как живут объекты оркестрации, и клиентов, на которых эти объекты крутятся

![[Pasted image 20241130184326.png]]

В отличие от сервисов в Docker Swarm, в Nomad мы создаем рабочие сущности job. Они, в свою очередь, состоят из task. 

Чтобы создать job, мы пишем манифест и передаем его серверу, а он уже распределяет их по клиентам.

![[Pasted image 20241130184441.png]]

Одно из главных отличий Nomad от других оркестраторов — он может оркестрировать не только Docker-контейнеры. И вообще не только контейнеры. Это могут быть и виртуальные машины, и бинарники Java, и даже Amazon Elastic Container Service.

Nomad — может управлять GPU-ресурсами вашего сервера, поэтому подходит для проектов типа ML.

#### Плюсы
- Низкий порог входа
	- Прост в первоначальной настройке. Чтобы запустить, нужно:
		1. Установить пакет Nomad.
		2. Структурировать серверы: в основном нужно только указать адреса машин, на которых он будет работать.
		3. Запустить Nomad.
	
- Поддержка экосистемы HashiCorp
- Управление GPU ресурсами
- Может работать в симбиозе с K8S
- Работает на всех ОС
- Поддерживаются **все** популярные и нужные стратегии обновления

#### Минусы
- Мало возможностей из коробки
- Нету автомасштабирования
- Малая поддержка сообщества
- Манифесты пишутся на HCL

---
## Kubernetes & OpenShift

- «Под капотом» Openshift находится Kubernetes

Kubernetes родился в стенах Google и был передан в open source. Среди сегодняшних контрибьюторов разработки Kubernetes используют множество крупных компаний. Он работает на Linux и Windows.

Openshift работает исключительно на Red Hat Enterprise Linux. Имеет только Enterprise-версию с небольшим тестовым периодом. Помимо Kubernetes, там есть много других технологий: для доставки кода, мониторинга, сбора логов и т.д.

### Архитектура

![[Pasted image 20241130185504.png]]

#### Control Plane включает в себя:
##### 1. kube-api-server 
- центральная точка входа для всех компонентов Kubernetes и людей, которые работают с кластером. 
- Он предоставляет api для управления кластером
##### 2. kube-controller-manager 
- управляет контроллерами
- *@:* node controller, который следит за node
- *@:* replica controller, который следит за количеством подов, развернутых в нашем кластере
##### 3. kube-sheduler 
- определяет, когда и на каком узле будет работать под
##### 4. хранилище etcd
- в нем хранятся состояния кластера в формате ключ-значение
##### 5. cloud-contoller 
- его наличие опционально
- Он следит за контроллерами определенного публичного или приватного облака
#### На узлах работают:
##### kubelet
- разворачивает и следит за контейнерами
##### kube-proxy
- занимается сетью: настраивает сеть и сетевые правила так, чтобы поды на разных узлах могли друг с другом общаться

### Масштабирование

Kubernetes предоставляет широкие возможности по масштабированию.

![[Pasted image 20241130190313.png]]

При вертикальном масштабировании мы можем определить request, количество ресурсов, которые будут даны приложению при старте, и лимиты, до которых оно может расширяться, затрачивая больше ресурсов.

По средней нагрузке Kubernetes может следить за репликами и узлами, добавляя или уменьшая их количество. Так же он работает в облаке, покупая или продавая узлы

### Рабочая сущность k8s & OpenShift

Минимальная рабочая сущность обоих оркестраторов — pod

![[Pasted image 20241130190732.png]]

***Pod*** - контейнер, который может быть основан и на Docker, и на cri-o, и на containerd. Но это обязательно будет контейнер, в отличие от Nomad, который может оркестрировать виртуальные машины и много чего еще.

В поде **необязательно** будет только один контейнер. Их может быть несколько, и они будут делить между собой сетевое дисковое пространство. 

Чтобы создать под, мы пишем простой yaml-файл и либо применяем его, либо запускаем из командной строки напрямую. Для управления Kubernetes используется довольно популярная утилита *Kubetail*.

### Итог

У Kubernetes большое количество встроенных возможностей. Здесь есть все необходимое, что требуется от оркестратора, к тому же есть возможность постоянно расширять его возможности с помощью кастомного API, сетевых плагинов, инструментов для установки и управления кластеров и т.д.

Kubernetes имеет развитое сообщество, очень заинтересованное в технологии. Можно решить практически любую проблему, или найти инженера, который будет работать с Kubernetes.

Одновременный плюс и минус Openshift — то, что платформа выбрана за вас. С одной стороны, можно сразу взять ее и пользоваться, а с другой — не факт, что она лучше всего подойдет именно вам. Возможно, придется ставить что-то рядом и пользоваться всем по частям. Поэтому тут присутствует vendor lock-in: переехать с Openshift на какой-то другой оркестратор будет достаточно проблематично.

Т.к. это Enterprise, у Openshift есть коммерческая поддержка. У Kubernetes ее нет, зато есть большое сообщество open source, хорошая подробная документация и множество статей и книг. К тому же огромный выбор технологий для пользователя.
#### Плюсы
- Просто запустить в публичных облаках.
- Из коробки Kubernetes поддерживает только две стратегии обновлений: Rolling и Recreate.
- Поддерживает Rollback: следит за статусом пода и health-check.
- Kubernetes позволяет описывать свои манифесты на yaml и JSON. yaml предпочтительнее, им пользуется большинство.

#### Минусы
- Оба достаточно сложны для самостоятельной установки

---