---
tags:
---

---
## Контейнеры

#### docker run \[id/Имя контейнера]
- *@: docker run redis*
- команда запуска контейнера из образа Docker
- запускает экземпляр приложения на персональном Docker-хосте
- если образ присутствует локально - просто запускает его
- если образ не присутствует локально - Docker сходит на Docker hub и спулит
этот образ себе (один раз и навсегда)
- без указания тэга (версии) будет скачан образ последней версии

#### docker run \[id/Имя контейнера]:\[тэг/версия образа]
- *@: docker run redis:5.0*
- скачивает образ указанной версии

#### docker run --name=\[выбранное имя] \[выбранный образ]
- запускает контейнер из образа с выбранным именем

#### docker run -it \[имя контейнера] (sh)
- **-it** позволяет войти внутрь контейнера при запуске
- *sh* (опционально) - запускает shell при работе с контейнером linux
	- shell увидела терминал и стала работать с ним
	- пока shell видит терминал будет существовать главный процесс

#### docker stop \[id/NAMES]
- останавливает работающий контейнер

#### docker stop $(docker ps -q)
- останавливает все работающие контейнеры

#### docker rm \[id/NAMES]
- удаляет выбранный контейнер
- для удаления контейнер должен завершить свою работу (Exited) или остановлен (Stopped)
- в случае успеха возвращает имя контейнера или его id

#### docker rm $(docker ps -aq)
- удаляет абсолютно все контейнеры

#### docker ps
- выводит список запущенных контейнеров, а также информацию о каждом

#### docker ps -a
- выводит список всех контейнеров (даже не запущенных) и инфу о них

#### docker ps -aq
- выводит список **ID** всех контейнеров (даже не запущенных)

#### docker exec \[id/NAMES] \[команда] (контейнера)
- выполнение команды на работающем контейнере
- менять конфигурацию на работающем приложении - не лучшая идея
@: docker exec ubuntu cat /etc/hosts
    - вывод хостов из образа ubuntu внутри выбранного контейнера
    - обращение происходит к контейнеру, а не к хостовой (главной) ОС

---
## Attach & detach - режимы работы контейнера


**Attach mode** - режим, где контейнер после запуска прикрепляется к консоли. Взаимодействие с ним невозможно (т.к. консоль используется только для логов приложения)

@: 
**docker run [rotorocloud/webapp]**
    - можно только принудительно остановить контейнер (CTRL + C). Контейнер остановится и доступ к консоли возобновится

**Detached mode** - запускает контейнер в фоновом режиме, что дает возможность взаимодействовать с оболочкой (консолью). Для этого используется флаг -d после run

@: 
**docker run *-d* [rotorocloud/webapp]**

В любой момент можно прикрепить приложение к консоли через команду:
**docker attach \[ID/NAME]** (контейнера)

---
## Docker compose

#### docker-compose up -d
- Запуск контейнеров (описанных в compose файле) в фоновом режиме

#### docker-compose stop
- Останавливает контейнеры (описанные в compose файле)

#### docker-compose down
- Останавливает и удаляет, контейнеры созданные с помощью compose файла. Так же удалит тома (volume) и сети созданные для контейнеров

#### docker-compose ps
- Отображает список всех контейнеров запущенные с помощью compose файла

---
## Образы

#### docker images
- выводит список доступных образов на Docker-хосте

#### docker images -q
- выводит список ID всех докер-образов на Docker-хосте

#### docker build .
- Создание образа на основе Dockerfile

#### docker rmi \[Image-name]
- удаляет выбранный образ
- ВНИМАНИЕ: контейнеры, зависящие от этого образа не должны быть запущенны в системе
- Перед удалением необходимо остановить и удалить все связанные с ним контейнеры

#### docker rmi $(docker images -q)
- удаляет абсолютно все образы

#### docker pull \[Image-name]
- Скачивание образа из репозитория, скачается из Docker Hub
- чтобы контейнер не докачивал данный зависимый образ
- *@:* docker pull postgres

#### docker push \<repository>
- Загрузка образа в репозиторий
- *@:* docker push registry.example.com\/group/project/image

#### docker login \<repository>
- Авторизация для доступа в приватный репозиторий.
- Логин/Пароль
- *@:* docker login registry.example.com

---







