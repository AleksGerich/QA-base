---
tags:
---

---
## Поиск образов

[Hub-Docker](https://hub.docker.com/)
## Песочницы

- [Play with Docker](https://labs.play-with-docker.com/)

## Курс

[Курс по Docker (как на степике, только лучше)](https://rotoro.cloud/lessons/%d0%b2%d0%b2%d0%b5%d0%b4%d0%b5%d0%bd%d0%b8%d0%b5/)

---

**Docker** - программное обеспечение для автоматизации развёртывания и управления приложениями в средах с поддержкой контейнеризации, контейнеризатор приложений. Позволяет «упаковать» приложение со всем его окружением и зависимостями в контейнер, который может быть развернут на любой Linux-системе с поддержкой контрольных групп в ядре, а также предоставляет набор команд для управления этими контейнерами.

## Устройство докера

Важно помнить, что Docker не является виртуальной машиной, а представляет собой инструмент для изоляции процессов или задач. Он использует средства контейнеризации (cgroups + namespaces) в ядре Linux. Однако, Docker имеет множество схожих возможностей с виртуализацией:
- **Независимость**: контейнеры могут быть перенесены на любую операционную систему с установленной службой Docker, и они будут работать. Хотя официально это подтверждается, на практике не всегда гарантируется такая полная совместимость. 
- **Самодостаточность**: контейнеры выполняют свои функции независимо от того, где они запущены. Они не зависят от конкретной операционной системы или окружения, что обеспечивает их переносимость и удобство использования.

![[Pasted image 20241130160752.png]]
  
***Основные отличия от виртуализации:***
- Внутри контейнера находится минимально необходимый набор софта, необходимый для работы вашего процесса. Это уже не полноценная ОС, которую надо мониторить, следить за остатком места и так далее.
- Запуск виртуальной машины требует загрузки всей операционной системы гостя, что может занимать значительное время. Docker контейнеры запускаются намного быстрее, так как они используют общее ядро операционной системы хоста и не требуют загрузки всей операционной системы.
- Виртуальные машины требуют отдельной операционной системы для каждой VM, что приводит к большим размерам и использованию большего количества ресурсов (памяти, дискового пространства). Docker контейнеры используют общую операционную систему хоста, что делает их более легковесными и экономичными в использовании ресурсов.
- Docker контейнеры могут быть легко перенесены и запущены на любой платформе, поддерживающей Docker, без необходимости изменения кода или настройки. Виртуальные машины, с другой стороны, требуют совместимости с гипервизором и операционной системой хоста.

## Из чего состоит

![[Pasted image 20241130161757.png]]

Контейнер в Docker существует только в том случае, если существует процесс, вокруг которого он создан. Внутри контейнера этот процесс имеет идентификатор процесса (PID) равный 1. Рядом с процессом PID=1 можно создавать сколько угодно других процессов в пределах возможностей ОС. Однако, если процесс с PID=1 будет убит или перезапущен, контейнер будет остановлен.

Внутри контейнера стандартное расположение директорий, соответствующее стандартам Filesystem Hierarchy Standard (FHS). Расположение директорий в контейнере идентично исходному дистрибутиву, из которого был создан контейнер.

Важно отметить, что данные, созданные внутри контейнера, остаются только внутри контейнера и не сохраняются где-либо еще *(за исключением доступа к этому слою из хостовой операционной системы - volume)*. Если контейнер будет удален, все изменения данных будут потеряны. Поэтому рекомендуется хранить данные вне контейнера, на хостовой операционной системе.

## Образы (Images)

Docker образ (image) представляет собой структуру, состоящую из нескольких слоев. Каждый слой образа представляет собой результат выполнения команды в Dockerfile - файле, который определяет инструкции для создания образа. Образ можно рассматривать как шаблон, на основе которого можно запускать контейнеры. Контейнеры, или экземпляры, являются запущенными экземплярами образа. То есть, с одного образа можно запустить несколько одинаковых копий - контейнеров.  

Кроме того, после выполнения определенных операций внутри контейнера, можно создать новый образ на основе изменений, сделанных в контейнере. Это позволяет сохранить изменения и использовать их в будущих контейнерах. Все эти образы, контейнеры и слои хранятся в системе Docker в директории */var/lib/docker*

Для создания собственных контейнеров в Docker используется механизм сборки, известный как *docker build*. Этот механизм использует набор инструкций, определенных в *Dockerfile*, для создания пользовательского образа. При сборке контейнера внутри используется оболочка sh, в которой выполняются указанные команды.

![[Pasted image 20241130174145.png]]

- Read-Only шаблон с набором инструкций, предназначенных для создания контейнеров
- Образ состоит из неизменяемых слоев, каждый из которых добавляет/удаляет/изменяет файлы из предыдущего слоя.
- Неизменяемость слоев позволяет их использовать совместно в разных образах.

Важно знать следующее:
- **Каждая выполненная команда создает слой файловой системы**, содержащий результаты изменений, вызванных этой командой. Например, выполнение команды apt install python3 создаст слой, содержащий бинарные файлы, библиотеки и другие зависимости, необходимые для установки python3. В конечном итоге каждый слой будет наложен друг на друга, а затем на исходный образ операционной системы, что приведет к получению конечного результата.
- **Слои являются независимыми друг от друга**. Это означает, что служба, запущенная в процессе сборки контейнера, существует только в пределах своего слоя. Например, при попытке загрузки базы данных PostgreSQL обычным способом, необходимо запустить PostgreSQL-сервер и затем выполнить команду загрузки базы данных. Однако в Docker это не сработает таким образом. Создается слой, который сохранит результаты запуска PostgreSQL (логи и т.д.), а затем PostgreSQL завершится. В следующем слое (при выполнении команды загрузки базы данных) PostgreSQL уже не будет запущен, что приведет к ошибке. Решением этой проблемы является объединение команд с помощью оператора &&.
- **Постоянные данные будут накладываться от первой команды до последней**, сохраняясь от слоя к слою. Это означает, что при создании файла в первой команде вы сможете обращаться к нему и в последующих командах.

## Откуда брать контейнеры и образы

Существуют публичные и приватные репозитории образов. Называемые **Docker Registry**. Наиболее крупный и популярный - это Docker Hub.

Docker Registry является важным инструментом для хранения и обмена контейнерами между различными пользователями, командами или автоматизированными процессами. Он предоставляет единое место для хранения образов контейнеров, которые могут быть легко загружены и распространены с помощью всего одной команды. Кроме того, контейнеры имеют небольшой размер по сравнению с виртуальными машинами, что делает их более эффективными в использовании ресурсов.

Однако стоит отметить, что Docker Registry не хранит данные рабочих контейнеров. Он предназначен исключительно для хранения и обмена образами контейнеров. Это позволяет создавать удобный рабочий процесс: разработчики создают продукт, собирают новый контейнер и загружают его в репозиторий. Затем тестировщики могут получить этот контейнер, протестировать его и дать одобрение. Далее, с помощью инструментов автоматизации (SMC), таких как *Ansible*, операционные команды могут развернуть контейнеры на производственных серверах. Используя Ansible и Docker Registry, можно легко масштабировать развертывание контейнеров на одном или множестве серверов.

Также стоит отметить, что Docker Registry интегрируется хорошо с системами непрерывной интеграции (CI). Новые версии контейнеров могут быть автоматически загружены с помощью серверов сборки (build servers)

## Docker Compose

Docker Compose является компонентом Docker, представляющим собой инструментальное средство, разработанное для облегчения процесса развертывания проектов. Оно предоставляет возможность определения и управления множеством контейнеров, составляющих приложение, в единой конфигурационной сущности. Docker Compose обеспечивает удобный способ описания и настройки различных сервисов, их зависимостей, сетевых параметров и других аспектов, необходимых для успешного развертывания проектов.

![[Pasted image 20241130180443.png]]

- Docker – инструмент для эффективного управления отдельными контейнерами.
- Docker Compose – инструмент для эффективного –одновременного несколькими контейнерами, которые входят в состав приложения
#### Разница между Docker и Docker Compose

Docker является инструментом, предназначенным для эффективного управления отдельными контейнерами, которые составляют приложение. Он обеспечивает изоляцию и легкость развертывания приложений, позволяя запускать и управлять каждым контейнером независимо.
  
Docker Compose - предоставляет возможность одновременного управления несколькими контейнерами, которые входят в состав приложения. Этот инструмент позволяет определить и настроить зависимости между контейнерами, а также управлять их конфигурацией и развертыванием. Docker Compose предоставляет те же функциональные возможности, что и Docker, но предназначен для работы с более сложными приложениями, состоящими из нескольких взаимодействующих контейнеров.
#### Пример сценария использования Docker Compose

Docker Compose представляет собой мощный инструмент, который обеспечивает быстрое развертывание приложений с сложной архитектурой. В данном контексте, будет рассмотрен практический пример использования Docker Compose, чтобы можно было оценить его преимущества.

*@:*
Есть веб-проект, который включает в себя два веб-сайта. Первый сайт предоставляет возможность бизнес-пользователям создавать интернет-магазины всего за несколько кликов. Второй сайт ориентирован на поддержку клиентов. Оба сайта взаимодействуют с одной и той же базой данных.
  
С ростом популярности проекта - текущая серверная инфраструктура недостаточна. В результате принимается решение перенести проект на другой сервер.
  
Однако, предположим в данном случае не использовался Docker Compose, и приходиться переносить и настраивать сервисы вручную, с риском пропустить какие-либо настройки.
  
В случае использования Docker Compose, перенос проекта на новый сервер становится вопросом выполнения нескольких команд. Для завершения переноса проекта на новое место потребуется выполнить некоторые настройки и загрузить резервную копию базы данных на новый сервер.

---
## Кратко суммируя:

1. Образ Docker - шаблон приложения и его зависимостей, собранных вместе
2. Контейнер Docker - экземпляр образа
3. Каждый контейнер получает случайным образом выбранный ID и случайное имя, если оно не было указано при создании.
4. Контейнер докер работает только при существовании неоконченного главного процесса в контейнере. Если данный процесс закончился (или отсутствует), то контейнер останавливается (Exited). 

@: если мы запустим контейнер из образа Ubuntu при помощи команды `docker run ubuntu` это запустит экземпляр ubuntu и немедленно выйдет из него (Exited)

(Потому что ОС сама является площадкой для запуска процессов, у нее не было процесса по умолчанию, того огонька, что поддерживал бы жизнь в контейнере.)

Если очень хочется чтобы контейнер работал без процесса внутри, то можно самому его создать
@: run ubuntu sleep 500
    - будет работать пока не истечет таймер

5. При прописывании **id** не обязательно указывать полный id контейнера (достаточно первых нескольких символов, если на Docker-хосте *нет дублирования*)
6. После запуска контейнера (docker run) создается копия указанного контейнера из Docker-хоста. Это означает, что после остановки (или завершения работы) эти копии остаются (ps -a). 
	- Для очистки от этих однотипных копий и используется *docker rm \[имя контейнера или ID]
