---
tags:
  - принципы_тестирования
  - сложности_тестирования
  - технологии_тестирования
  - методы_тестирования
  - уровни_тестирования
  - виды_тестирования
  - функциональное_тестирование
  - iso_9126
  - пирамида_тестирования
---

---
#принципы_тестирования
# Принципы тестирования

1. Тестирование демонстрирует наличие дефектов, а не их отсутствие
2. Исчерпывающее тестирование невозможно
3. Раннее тестирование (чем раньше, тем лучше)
4. Скопление дефектов (20% модулей содержат 80% багов)
5. Парадокс пестицида
6. Тестирование зависит от контекста (тип продукта, цель, риски, инструменты, время ...)
7. Заблуждение об отсутствии ошибок (Нет гарантии нахождения всех ошибок. Нет гарантии полностью готового и качественного продукта. Нахождение дефектов не имеет смысла, если продукт не удовлетворяет нужд пользователей)

---
#сложности_тестирования
# Основные сложности тестирования

1. Недостаток прозрачности (сложно «посмотреть» на программный продукт и оценить степень его завершённости в меру его концептуальности и абстрактности)
2. Недостаток контроля (Сложно оценить объём выполненной и оставшейся работы)
3. Недостаток прослеживаемости (Сложно установить связь между проблемами. Решение проблемы в одной области может привести к возрастанию проблемы в другой)
4. Недостаток мониторинга (если нет инструмента слежения за фактической разработкой продукта в проекте)
5. Неконтролируемые изменения (поток идей от пользователей)
6. Групповой синдром разработчика (противоречие идей группы разработчиков)
7. Множественность версий (изменения должны быть реализованы во всех версиях)
8. Разные ОС (свой алгоритм работы на каждой ОС)
9. Изменение графика работ (все должно быть грамотно распределено)
10. Изменение штата (нужна хорошая документация для быстрого вливания новых работников)
11. Изменение во внешней среде (строить планы на проект с учетом времени)

---

**Жизненный цикл тестирования:**
![[Pasted image 20241016140543.png]]

---
# Верификация и валидация

***Верификация*** - оценка соответствия ПО заявленным требованиям в спецификациях

***Валидация*** - оценка соответствия ПО ожиданиям и требованиям конечного пользования

![[Pasted image 20241126160954.png]]

---
# Этапы тестирования

### **Этап 1: Оценка плана разработки и состояния проекта**

Предварительный этап, в котором задействуются _верификация_, _валидация_ и _план тестирования_. 
На этом этапе тестировщики, со своей точки зрения, оценивают полноту и корректность _плана разработки_, включая тестирование. Основываясь на _расширяемости_ и _полноте плана проекта_, тестировщики оценивают количество ресурсов, которые будут выделять на тестирование в этом проекте.

### **Этап 2: Разработка плана тестирования**

Создание плана тестирования вполне стандартный процесс, не выходящий за рамки общего паттерна _планирования_ программных продуктов. Структура плана тестирования описывается стандартом IEEE, контекст зависит от проекта, и от скиллов команды.

### **Этап 3: Сбор требований**

Неполные, неточные, несогласованные _требования_ вызывают, возможно, большинство проблем в программных продуктах. Неспособность получить качественно сформулированные требования на 3-м этапе значительно увеличивает стоимость продукта и вызывает задержки. Тестировщики во время верификации требований должны гарантировать, что требования точные, полные, и не противоречат друг другу.

### **Этап 4: Тест-дизайн**

Этап оценки как «внешнего», так и «внутреннего» дизайна, главным образом это техники верификации. QA-команда позаботится, чтобы планирование было эффективным, особенно что касается окружения и аппаратной части.

### **Этап 5: Тестирование билда**

Метод, выбранный для билда продукта во внутреннем дизайн-документе, будет определять тип и объем тестирования, количество привлеченных тестировщиков. Если автоматизация внедрена в больших масштабах, понадобится меньше ручного тестирования на этом этапе. Если продукт делается по [модели водопада](https://testengineer.ru/v-model-testirovaniya/#waterfall-model-example), он довольно уязвим к ошибкам и должен будет проходить дополнительные _верификации_. В целом, значительно дешевле обнаруживать и устранять дефекты на раннем этапе разработки, чем на более позднем, во время [_динамического тестирования_](https://testengineer.ru/chto-takoe-staticheskoe-dinamicheskoe-testirovanie/#h--2).

### **Этап 6: Выполнение тестов и фиксация результатов**

Тестирование кода при его выполнении (то есть [динамически](https://testengineer.ru/chto-takoe-staticheskoe-dinamicheskoe-testirovanie/)). Подходы, методы, и инструменты, изложенные в _плане тестирования_, будут задействованы сейчас и покажут свою эффективность. Происходит проверка, соответствует ли выполняемый код требованиям, и _структурным спецификациям_.

### **Этап 7: Приемочное тестирование**

Этап приемочного тестирования: конечные пользователи оценивают работоспособность и полезность приложения при выполнении его основных функций. Продукт проверяется _с точки зрения пользователя_, что может немного отличаться от задокументированных _требований_.

### **Этап 8: Репорты и результаты тестов**

Репорты, то есть отчеты и промежуточные результаты в процессе тестирования, поступают постоянно. Репорт может быть как письменным, так и устным. Важно, чтобы дефекты и/или уточнения по продукту были зафиксированы как можно раньше, а значит корректировки были сделаны как можно раньше — это экономия времени и усилий.

### **Этап 9: Установка продукта**

QA-команда подтвердила, что продукт готов к передаче в _продакшен_, тогда переходят к установке и тестированию в _прод-окружении_ (в реальных условиях). Идет тестирование продукта в операционной системе, уточняется взаимодействие со связанными продуктами, и другие стандартные процедуры в реальном _окружении_.

### **Этап 10: Корректировки**

Этап обслуживания/поддержки готового продукта, в том числе maintenance-тестированием. Требования к продукту могут изменяться/совершенствоваться и на этом позднем этапе, поэтому в тест-план могут вноситься изменения; корректировки/совершенствования продукта должны быть протестированы и оценены QA-командой.

### **Этап 11: Оценка эффективности тестирования**

Финальный этап: оценка эффективности QA-команды на этом проекте. Оценивают сами тестировщики (точнее [лиды](https://testengineer.ru/kak-stat-qa-lidom/)), а еще лучше, если работу команды оценят разработчики, пользователи, и специалисты по качеству (QC), если такая должность [есть](https://testengineer.ru/raznica-mezhdu-qa-i-qc/) в организации.


https://testengineer.ru/software-testing-steps/

Тестовые активности существуют до и после выполнения тестов:
- Планирование, контроль, мониторинг
- Выбор условий тестирования
- Проектирование тестов
- Проверка результатов
- Оценка критериев выхода
- Отчетность по процессу тестирования и тестируемой системе
- Закрытие или завершение тестирования
- Обзор документов
- Статический анализ
https://sedtest-school.ru/foundation/etapy-aktivnosti-testirovaniya/

---
#технологии_тестирования
# Статическое тестирование (static testing):

Процесс анализа самой разработки программного обеспечения, иными словами – это тестирование без запуска программы. Статическое тестирование предусматривает проверку программного кода, требований к программному продукту, функциональной спецификации, архитектуры, дизайна и т.д. Статическое тестирование является одним из наиболее эффективных способов выявления дефектов на ранних стадиях работы над проектом, благодаря чему достигается существенная экономия времени и затрат на разработку
# Динамическое тестирование (dynamic testing): 

Тестовая деятельность, предусматривающая эксплуатацию (запуск) программного продукта. Динамическое тестирование включает в себя запуск программы, выполнение всех её функциональных модулей и сравнение её фактического поведения с ожидаемым.

---
#методы_тестирования
# Метод Белого ящика 

Для тестирования программного кода без его непосредственного запуска
применяется метод белого ящика (white-box testing, glass-box testing).
При тестировании с использованием метода белого ящика тестировщик
имеет доступ к исходному коду ПС и может писать код, который связан с
библиотеками тестируемого ПС. Это типично для компонентного тестирования
(юнит-тестирования, unit-testing), при котором тестируются только отдельные части системы. Такие тесты основаны на знании кода приложения и
его внутренних механизмов.

Используется на стадии, когда приложение ещё не собрано воедино, но необходимо проверить каждый из его компонентов, модулей, процедур и подпрограмм.

## Разработка тестов методом белого ящика:

Написание тестов основываясь на структуре кода приложения (structural based):
- Покрытие операторов  (test coverage) – все ли переменные (x, y, z) в коде были проверены (покрыты) набором тестов;
- Покрытие условий (condition coverage): все ли пути исполнения кода (if - else) были проверены (покрыты) набором тестов;
- Покрытие решений (decision coverage): все ли варианты исполнения кода ( true, false) были проверены (покрыты) набором тестов.

Написание тестов основываясь на внутренней структуре и коде приложения (structural based):
- Может быть представлено на всех уровнях тестирования;
- Лучше всего использовать после тестирования на основе спецификации (тестирование методом черного ящика);
- На всех уровнях тестирования могут быть использованы специальные инструменты для измерения покрытия элементов кода;

---
# Черный ящик

При использовании метода чёрного ящика (black-box testing) тестировщик
имеет доступ к ПО только через те же интерфейсы, что и заказчик или
пользователь, либо через внешние интерфейсы, позволяющие другому компьютеру
либо другому процессу подключиться к системе для тестирования. 

Написание тестов основываясь на анализе функциональной или нефункциональной спецификации приложения (specification based):

Эквивалентное разбиение		  (Equivalence Partitioning, EP);
Анализ граничных значений		  (Boundary Value Analysis, BVA);
Тестирование таблицы решений	  (Decision Table Testing);
Тестирование таблицы переходов	  (State Transition Testing);
Тестирование сценариев использования (Use Case Testing);
Синтаксическое тестирование		  (Syntax Testing);
Выборочное тестирование 		  (Random Testing);

---
# Метод серого ящика

Существует также метод серого ящика (gray box testing), который представляет
собой нечто среднее между методами белого и чёрного ящиков.Этот метод, как правило, используется при тестировании веб-приложений,
когда тестировщик знает принципы функционирования технологий, на которых
построено приложение, но может не видеть кода самого приложения. 

---
#уровни_тестирования
# Уровни тестирования

1. **Модульное тестирование** - тестирование отдельных участков кода, классов, методов, максимально отделенные от других элементов и, в то же время, пригодные для тестирования. Такое тестирование обычно проводится сразу же вслед за разработкой каждого из элементов и направлено на оценку соответствия функциональности каждого из компонентов спроектированной “модели компонентов”. ([Модульное тестирование](https://testengineer.ru/unit-testirovanie/))
	
	Различия *модульного тестирования* от *unit-тестирования*:
	
	- *Глубина изоляции*. Unit-тесты изолируют каждую функцию, а модульные тесты проверяют взаимосвязанную группу функций для выполнения ожидаемой работы одного модуля.
	- *Уровень ответственности*. Unit-тесты обеспечивают корректность конкретного блока логики, модульные тесты отвечают за работу модуля как целого.
	- *Подход к зависимостям*. В unit-тестах используются моки для всех зависимостей, тогда как в модульных тестах иногда разрешается минимальное количество взаимодействий с реальными зависимостями.
	- **Модульное тестирование больше ориентировано на QA**
		- unit-тесты пишутся разработчиками (зачастую)
		- модульные - тестировщиками (@: возможность занести данные в табличку)
	
2. **Интеграционное тестирование** - поиск дефектов, связанных с ошибками в реализации и интерпретации взаимодействия между модулями.
	- Проверка того, как отдельные модули приложения взаимодействуют между собой
	- Проверка того, как приложение взаимодействует с каким-то внешним приложением или компонентом системы
	
3. **Системное тестирование** - Процесс тестирования системы в целом с целью проверки того, что она соответствует установленным требованиям 
	
	Тестирование полной системы:
	- Может быть последним шагом в интеграционном тестировании в узком смысле;
	- Может быть первый раз, когда из компонентов появляется рабочая система.
	- В идеале – проводится независимой тестовой командой.
	
4. **Приёмочное тестирование (acceptance testing)** - Тестирование по отношению к потребностям, требованиям и бизнес процессам пользователя, проводимое с целью дать возможность пользователям, заказчикам определить, принимать систему или нет. 
   ([Приемочное тестирование](https://testengineer.ru/uat-testirovanie/))

---
#виды_тестирования
# Виды тестирования

1. **Инсталляционное тестирование (installation testing)** - Установка и удаление ПО
	
2. **Регрессионное тестирование (regression testing)** - Регрессионное тестирование проводится с целью проверить, не влияют ли новые функции, улучшения и исправленные дефекты на существующую функциональность продукта и не возникают ли старые дефекты.
	*Выбор тестов для регрессионного тестирования:*
	- Тесты, которые покрывают безопасность или критически важные функции для бизнеса;
	- Тесты областей, которые регулярно меняются;
	- Тесты функций с высокой вероятностью ошибок;
	- Выбор правильных тестов очень важен и требует определенной степени знания приложения и его предполагаемого развития.
	 
	 Регрессионное тестирование **идеальная основа для автоматизации**
	
	**Когда проводить** регрессионное тестирование:
	- Как только ошибка исправлена, приложение должно быть протестировано повторно.
	- Новые ошибки могут появляться в результате исправления старых.
	- Существующие недочеты, возможно, не были покрыты исправлением.
	- Тесты должны разрабатываться с целью их повторного использования.
	- Повторное тестирование – это перезапуск «провалившихся» тестов после исправления ошибок, чтобы убедиться, что исправленное работает.
	- Регрессионное тестирование -  это запуск более широкого набора тестов, чтобы проверить, не появились ли неожиданные ошибки в коде, который не меняли.
	
3. **Тестирование новой функциональности (new feature testing)** - В данном виде тестирования акцент делается на тестировании новой функциональности, появившейся в конкретном выпуске (build) программного продукта
	
4. **Конфигурационное тестирование (configuration testing)** - С помощью конфигурационных тестов проверяется совместимость продукта с различным программным (software) и аппаратным (hardware) обеспечением
	
5. **Тестирование совместимости (compatibility testing)** - Тестирование совместимости помогает убедиться в функциональных возможностях и надёжности работы продукта в поддерживаемых браузерах (если речь идет о Web-приложениях) и операционных системах. Также может проверяться работоспособность продукта при использовании различных аппаратных платформ.
	
6. **Тестирование удобства эксплуатации (usability testing)** - Тестирование интерфейса человек/машина производится в отношении таких моментов как внешний вид пользовательского интерфейса, удобство навигации (преимущественно для Web-сайтов)
	
7. **Тестирование безопасности (security testing)** - Стратегия тестирования, используемая для проверки безопасности системы, а также для анализа рисков, связанных с обеспечением целостного подхода к защите приложения, атак хакеров, вирусов, несанкционированного доступа к конфиденциальным данным.
	
8. **Тестирование прототипа (prototype testing)** - Основная цель тестирования прототипа – выявить потенциальные проблемы в приложении, проверить, насколько приложение соответствует потребностям и ожиданиям пользователя и обнаружить расхождения с требованиями к графическому интерфейсу пользователя.
	
9. **Локализационное тестирование (localisation testing)** - Проверяет, насколько корректно продукт адаптирован к работе на том или ином языке: всё ли переведено и переведено правильно, не нарушилась ли логика построения интерфейса и обработки данных и т.д.
	
10. **Исследовательское тестирование (exploratory testing)** - Цель такого тестирования – на основе профессиональной интуиции тестировщика найти в приложении ошибки, которые могли быть пропущены классическими подходами к тестированию. 
	
11. **Тестирование документации (documentation testing)** - Вид тестирования, с которого начинается почти любой проект. Призвано обнаружить ошибки в документации. Эти ошибки опасны тем, что они, как маленький комок снега могут вызвать лавину проблем, вырастая на более поздних стадиях работы с проектом в очень сложноустранимые и дорогостоящие последствия.
	
12. **Тестирование производительности (performance testing)** -  проверка скорости работы системы (время отклика, частота транзакций и другие зависящие от времени) в имитационной и реальной средах
	
13. **Нагрузочное тестирование (load testing)** - Тестирование предназначено для проверки работоспособности системы при стандартных нагрузках и для определения максимально возможного пика, при котором система работает правильно.
	
14. **Стрессовое тестирование (stress testing)** - Тестирование предназначено для проверки работоспособности системы при нестандартных нагрузках и для определения максимально возможного пика, при котором система работает правильно. Так же предназначено для выявления результатов, при которых система переходит в нерабочее состояние. 
	
15. **Дымное тестирование (smoke test)** - первый прогон программы (после написания или после внесения существенных изменений). Как правило, используется для определения, готова ли программа для проведения более обширного тестирования
	
16. **Санитарное тестирование (sanity testing)** - проводится после smoke и перед регресом в относительно стабильном билде. Проверяет общее состояние важной части функциональности в деталях, чтобы приступить к более тщательному тестированию
	
17. **Re-test** - проводится перед sanity и заключается в повторном проведении тех же тестов после исправления багов.
	- [В чём разница Smoke, Sanity, Regression, Re-test и как их различать?](https://habr.com/ru/articles/358142/)
	
18. [GUI-тестирование](https://testengineer.ru/testirovanie-gui-polnoe-rukovodstvo/)

https://testengineer.ru/vidy-tipy-testirovaniya/

![[Pasted image 20241115172903.png]]

---
#функциональное_тестирование
# Функциональное тестирование

**Проверка функциональности (тестирование методом «черного ящика»)** – проверка соответствия программного обеспечения требованиям, заявленным в спецификации. Может проводиться как полное тестирование заявленной функциональность, так и проверка только базовой функциональности.

**Целями процесса функционального тестирования** в области качества являются:
	- Подтверждение качества программного продукта, соответствующего показателям, установленным заказчиком.
	- Обнаружение и документирование дефектов программного продукта.
	- Принятие объективного решения, зафиксированного в отчёте о результатах тестирования, о возможности поставки программного продукта заказчику

### Уровни функционального тестирования:

1. **Приемочный тест (Smoke test)** - первый и самый короткий тест, призванный проводить проверку основных элементов программного продукта и его работоспособности в целом. В случае функционального тестирования – проверяется основной функционал приложения. Тест занимает 1-4 часа в зависимости от сложности тестируемого продукта. На основе результатов данного теста принимается решение о приемке версии программного продукта и продолжении тестирования текущей версии продукта более серьезными тестовыми испытаниями.
	
2. **Тест критического пути (critical path test)** - Уровень тестирования, во время которого проверяется основная функциональность программного продукта, критичная для конечного пользователя, при стандартном его использовании. В рамках данного тестирования, как правило, проверяется большинство требований, предъявляемых к программному продукту
	
3. **Расширенный тест (extended test)** - Это углубленный тест, при котором проверяется нестандартное использование программного продукта. Прогоняются сложные, логически запутанные сценарии, совершаются действия, которые конечный пользователь будет совершать редко (границы переполнения массивов данных, ввод специальных символов и т.п.)

---
#iso_9126 #стандарты_качества
# Стандарты качества ПО по ISO 9126

[Стандарт](https://akkaparallel.blogspot.com/2013/04/iso-9126.html) ISO/IEC 25010:2011 определяет модель качества продукта, которая включает шесть характеристик верхнего уровня:

1. ***Функциональность*** - способность ПО в определенных условиях решать задачи, нужные пользователям. Определяет, что именно делает ПО, какие задачи оно решает
	
	- *Функциональная пригодность* - способность решать нужный набор задач.
	- *Точность* - способность выдавать нужные результаты
	- *Способность к взаимодействию* - способность взаимодействовать с нужным набором других систем
	- *Соответствие стандартам и правилам* - соответствие ПО имеющимся индустриальным стандартам, нормативным и законодательным актам, другим регулирующим нормам
	- *Защищенность* - способность предотвращать неавторизированный, т.е. без указания лица, пытающегося его осуществить, и неразрешенный доступ к данным и программам
	  
2. ***Эффективность*** - способность ПО при заданных условиях обеспечивать необходимую работоспособность по отношению к выделяемым для этого ресурсам
	
	- *Временная эффективность* - способность ПО выдавать ожидаемые результаты, а также обеспечивать передачу необходимого объема данных за отведенное время
	- *Эффективность использования ресурсов* - способность решать нужные задачи с использованием определенных объемов ресурсов определенных видов. Имеются в виду такие ресурсы, как оперативная и долговременная память, сетевые соединения, устройства ввода и вывода и пр
	- *Соответствие стандартам производительности*
	
3. ***Надежность***  -  способность  ПО  поддерживать  определенную  работоспособность в заданных условиях
	
	- *Зрелость, завершенность* - величина, обратная частоте отказов ПО. Обычно измеряется средним временем работы без сбоев и величиной, обратной вероятности возникновения отказа за данный период времени
	- *Устойчивость к отказам* - способность поддерживать заданный уровень работоспособности при отказах и нарушениях правил взаимодействия с окружением
	- *Способность к восстановлению* - Способность восстанавливать определенный уровень работоспособности и целостность данных после отказа, необходимые для этого время и ресурсы
	- *Соответствие стандартам надежности*
	
4. ***Сопровождаемость*** - Удобство проведения всех видов деятельности, связанных с сопровождение программ
	
	- *Анализируемость* - удобство проведения анализа ошибок, дефектов и недостатков, а также удобство анализа необходимости изменений и их возможных последствий
	- *Удобство внесения изменений* - показатель, обратный трудозатратам на выполнение необходимых изменений
	- *Стабильность* - показатель, обратный риску возникновения неожиданных эффектов при внесении необходимых изменений
	- *Удобство проверки* - показатель, обратный трудозатратам на проведение тестирования и других видов проверки того, что внесенные изменения привели к нужным результатам
	- *Соответствие стандартам удобства сопровождения*
	
5. ***Практичность*** - способность ПО быть удобным в обучении и использовании, а также привлекательным для пользователей
	
	- *Понятность* - показатель, обратный к усилиям, которые затрачиваются пользователями на восприятие основных понятий ПО и осознание их применимости для решения своих задач
	- *Удобство обучения* - показатель, обратный усилиям, затрачиваемым пользователями на обучение работе с ПО
	- *Удобство работы* - показатель, обратный усилиям, предпринимаемым пользователями для решения своих задач с помощью ПО.
	- *Привлекательность* - способность ПО быть привлекательным для пользователей.
	- *Соответствие стандартам удобства использования*
	
6. ***Переносимость*** - способность ПО сохранять работоспособность при переносе из одного окружения в другое, включая организационные, аппаратные и программные аспекты окружения
	
	- *Адаптируемость* - способность ПО приспосабливаться различным окружениям без проведения для этого действий, помимо заранее предусмотренных.
	- *Удобство установки* - способность ПО быть установленным или развернутым в определенном окружении. 
	- *Способность к сосуществованию* - способность ПО сосуществовать с другими программами в общем окружении, деля с ними ресурсы. 
	- *Удобство замены другого ПО данным* - возможность применения данного ПО вместо других программных систем для решения тех же задач в определенном окружении. 
	- *Соответствие стандартам переносимости*

Помимо перечисленных характеристик и атрибутов качества, стандарт ISO 9126:2001 определяет наборы метрик для оценки каждого атрибута. Вот некоторые примеры таких метрик.  

1. **_Полнота реализации функций_** — процент реализованных функций по отношению к перечисленным в требованиях. Используется для измерения функциональной пригодности.
2. **_Корректность реализации функций_** — правильность их реализации по отношению к требованиям. Используется для измерения функциональной пригодности. 
3. _**Отношение числа обнаруженных дефектов к прогнозируемом**_ -  Используется для определения зрелости. 
4. _**Отношение числа проведенных тестов к общему их числу**_. Используется для определения зрелости. 
5. _**Отношение числа доступных проектных документов к указанному в их списке**_. Используется для измерения удобства проведения анализа. 
6. _**Наглядность и полнота документации**_. Используется для оценки понятности.

---
#пирамида_тестирования
# Пирамида тестирования (в разработке)

https://testengineer.ru/testing-pyramid/

---