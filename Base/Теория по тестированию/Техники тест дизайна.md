---
tags:
  - классы_эквивалентности
  - граничные_значения
  - доменное_тестирование
  - попарное_тестирование
  - allparirs
  - орттогональные_массивы
---

---

Эквивалентное разбиение		  (Equivalence Partitioning, EP);
Анализ граничных значений		  (Boundary Value Analysis, BVA);
Тестирование таблицы решений	  (Decision Table Testing);
Тестирование таблицы переходов	  (State Transition Testing);
Тестирование сценариев использования (Use Case Testing);
Синтаксическое тестирование		  (Syntax Testing);
Выборочное тестирование 		  (Random Testing);

---
# Когда (примерно) что использовать

#### 1. Классы эквивалентности
- при выделении однородных групп данных с одинаковой логикой обработки

#### 2. Граничные значения
- при выделении однородных групп данных для проверки логики их обработки на границах

#### 3. Доменное тестирование
- при небольшом количестве тестируемых объектов (@: полей формы) с большим объемом различных входных данных (классы эквивалентности)

#### 4. Попарное тестирование (AllPairs)
- при среднем количестве тестируемых объектов (@: полей формы) и средним количестве входных (сокращенных по классам эквивалентности и граничным значениями) данных
- покрытие: 80-95%

#### 5. Попарное тестирование (Ортогональные массивы)
- предоставляет комбинации значений параметров (допустим для проведения полного кроссбраузерного тестирования)
- любые 2 столбца массива содержат все комбинации значений друг друга

#### 6. Таблица решений
- фиксирование требований
- описание безнес-логики
- особенно когда нет адекватной документации
- получаем общие тест-кейсы

#### 7. Тестирование состояний-переходов
- тоже подходит для фиксирования требований
- описывает бизнес-логику в виде диаграмм (в случае таблиц - все возможные варианты поведения)
- также наглядно показывает изменение состояний приложения при выполнении бизнес-логики

---
#классы_эквивалентности
# Классы эквивалентности

**Классы эквивалентности** - деление входных (иногда выходных) значений значений на группы, которые обрабатываются приложением одинаково (единый результат обработки)

@ (ОДНА СУЩНОСТЬ):
Требования:  
- если пользователь указал возраст до 18 лет, то предоставлять скидку 20%  
- пользователям 18-65 лет скидку не предоставлять  
- пользователям старше 65 лет предоставлять скидку 25%

Классы эквивалентности:
- 0..17(до 18 лет)  
- 18..65(18-65 лет)  
- 66..∞(старше 65 лет)

---
#граничные_значения
# Граничные значения

**Граничные значения** - техника основанная на риске возникновения ошибок на границах класса эквивалентности. Проверка этих значений

@:
Классы эквивалентности:
- 0..17(до 18 лет)  
- 18..65(18-65 лет)  
- 66..∞(старше 65 лет)

Граничные значения:
- 0
- 17, 18
- 65, 66

Проверка значений по технике граничных значений:
- {-1, 0, 1}
- {16, 17, 18}
- {17, 18, 19}
- {64, 65, 66}
- {65, 66, 67}

Удалив повторяющиеся значения получаем:
{-1, 0, 1, 16, 17, 18, 19, 64, 65, 66, 67}

---
#доменное_тестирование #domain_testing
# Domain testing

Domain - область определения
Domain testing - вид тестирование, в основе которого лежит тестирование на основе областей определения

**Domain testing** - техника тестирования на основе классов эквивалентности и граничных значений, позволяющая создавать тест-кейсы, покрывающие сразу несколько параметров одновременно. Цель - из всех возможных тест-кейсов создать минимально возможное их количество для необходимого покрытия

Цель доменного тестирования — предоставить стратегию по выбору минимального набора показательных тестов.

Задачи данного вида тестирования:
- Разбиение областей значения на подобласти
- Выбор конкретных значений из подобласти
- Сочетание выбранных значений 

Плюсы:
1. Полное покрытие невозможно, поэтому сокращаем
2. Минимизация риска выбрать ненужную подобласть
3. Увеличение покрытия тестов
4. Выявление дефектов при взаимодействии параметров

## Пример 1 (несколько полей)

*Ситуация:* необходимо протестировать форму авторизации:

![[Pasted image 20241128115448.png]]

Форма состоит из двух полей: логин и пароль. Длина логина и пароля — от 5 до 10 символов. Логин может принимать различные символы, цифры и буквы на латинице. Пароль тоже может принимать символы, цифры и латиницу

#### Шаг 1: Классы эквивалентности
- Кол-во значений от - ∞ до 4
- Кол-во значений от 5 до 10
- Кол-во значений 11 до + ∞
- Спец. символы
- Буквы (латиница)
- Цифры

#### Шаг 2: Выделяем значения для каждой группы:
- 4
- 5, 7, 10
- 11
- @, !, $
- a, b, w, l
- 2, 4

#### Шаг 3: комбинируем значения в виде таблицы

![[Pasted image 20241128124110.png]]

## Пример 2 (одно поле)

*Ситуация:* тестирование формы отправки суммы для подсчёта процента налога

![[Pasted image 20241128124743.png]]

1. Если сумма меньше 1000, то процент 0;
2. Если сумма от 1000 до 2000, то процент 10;
3. В случае, если сумма больше 2000, то процент 15;
4. Форма принимает только целочисленные значения;
5. Длина поля от 1 до 7 символов

#### Итоговая таблица с комбинированными значениями:

![[Pasted image 20241128124840.png]]

**Замечания:**
_Чем меньше позитивных тестов, тем меньше мы сможем сократить количество тестов. В данном случае мы сможем объединить только 2 теста: минимальное число символов и минимальное значение, то есть 0._

_В случае, если использование спецсимволов ведёт к ошибке, то рекомендуется каждый спецсимвол проверять отдельно._

https://sedtest-school.ru/test-design/chto-takoe-domennoe-testirovanie/
[Другой сурс (немного более подробно)](https://crashtest.by/domain-testing/#:~:text=%D0%94%D0%BE%D0%BC%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%E2%80%94%20%D1%8D%D1%82%D0%BE%20%D1%82%D0%B5%D1%85%D0%BD%D0%B8%D0%BA%D0%B0%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F,%D1%80%D0%B0%D0%B7%D0%B1%D0%B8%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%B8%20%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%20%D0%B3%D1%80%D0%B0%D0%BD%D0%B8%D1%87%D0%BD%D1%8B%D1%85%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D0%B9.)

---
#попарное_тестирование #pairwise_testing #allparirs
# Попарное тестирование - AllPairs

Техника Pairwise testing позволяет сократить количество тестов, необходимых для того, чтобы уверенно определить стабильность тестируемого продукта. Т.е. из всего множества тестов при применении этой техники составляется набор тестов с высоким процентом покрытия. Покрытие не достигает 100%, обычно варьируется от 80 до 95%. Но каждые несколько дополнительных процентов покрытия будут стоить нерационально много времени и ресурсов.

Суть: 
1. Сокращение числа изначальных значений переменных согласно бизнес-логике приложения (классы эквивалентности, граничные значения)
2. Построение таблицы: столбцы - тестируемые объекты, строки - значения объектов
3. Сортировка объектов (по кол-ву значений) по убыванию: слева-направо
4. Главная цель - создать всевозможные комбинации выбранных значений переменных внутри одной таблицы

## Пример применения

Есть форма, на которой:  
* Есть список - Может принимать значение от 0 до 9 включительно.  
* Есть поле ввода - может принимать целочисленные значения от 1 до 99 включительно.  
* Есть чекбокс1 - принимает значения on или off.  
* Есть чекбокс2 - принимает значения on или off.

Количество всего возможных комбинаций: 99\*10\*2\*2 = 3,960 возможных. Применяем алгоритм попарного тестирования

##### 1. Определяем кол-во входных параметров и значения входных параметров

![[Pasted image 20241105122502.png]]

##### 2. (По возможности) упрощаем значения параметров согласно бизнес-логике

- Классы эквивалентности
- Граничные значения

![[Pasted image 20241105122615.png]]

##### 3. Сортируем параметры по кол-ву значений в каждом

![[Pasted image 20241105122741.png]]

##### 4. Заполняем таблицу слева-направо

- Каждая строка таблицы будет представлять уникальный набор входных данных для теста. Внимательно, полностью сконцентрировавшись и отбросив все задние мысли смотрим сколько значений может принимать переменная второго столбца (список). 2 значения. Значит столько раз нужно вставить все значения первого столбца.

![[Pasted image 20241105122906.png]]

- Вставили 6 строк. 3 возможных значения поля ввода (первого столбца) значения повторяются дважды. 
- Так же мы пропустили по строке после каждого дубля значения - на случай, если понадобится добавить строки.

![[Pasted image 20241105124510.png]]

- Заполняем второй столбец. Для каждого дубля значений столбца 1 мы заполняем оба значения столбца 2.
- Получены все возможные комбинации пар значений первой и второй переменной.

![[Pasted image 20241105124618.png]]

- Третья переменная может принимать 2 значения - on и off. 
- Для каждого дубля значений столбца 1 мы заполняем оба значения столбца 3
- Есть ли все возможные комбинации значений между 1-ым и 2-ым столбцом? - Есть
- Есть все возможные комбинации значений между вторым и третьим столбцом? - НЕТ. У нас нет комбинации {0,off} и {other, on}.

![[Pasted image 20241105124841.png]]

- Меняем местами “on” и “off” в 3ем столбце у одной из пары дублей первого столбца.
- Теперь есть все возможные комбинации значений 1ой, 2ой и 3ей переменной.
- 4-ая переменная - **Checkbox2** тоже может иметь 2 возможных значения. Нам нужно подставить в таблицу эти значения так, чтобы все возможные комбинации значений каждой пары переменных существовали.

![[Pasted image 20241105125016.png]]

- Есть все возможные комбинации первого и четвертого столбца? Есть
- Есть все возможные комбинации второго и четвертого столбца? Есть
- Есть все возможные комбинации третьего и четвертого столбца? Еcть. 
- Получилось 6 тест кейсов, когда всего существует 24 возможных комбинации.

##### 5. Использование дополнительных (пропущенных) строк

- Добавим еще 2 чекбокса (2 бинарных входных параметра) - **Checkbox3** и **Checkbox4**. 
- Добавляем значения для 5ого столбца.

![[Pasted image 20241105125251.png]]

Проверяем свежезаполненый 5ый столбец по отношению к остальным столбцам поочереди:  
* к первому - все комбинации значений есть.  
* к второму - все комбинации значений есть.  
* к третьему - все комбинации значений есть.  
* к четвертому - все комбинации значений есть.

- Заполняем последний столбец

![[Pasted image 20241105125435.png]]

Проверяем 5-ый столбец по отношению к остальным столбцам по очереди:  
* к первому - все комбинации значений есть.  
* к второму - все комбинации значений есть.  
* к третьему - нет комбинаций значения{On, 2} и {Off, 1}.  
* к четвертой - все комбинации значений есть.  
* к пятой - все комбинации значений есть.

Вот тут нам и понадобятся пустые строки. 
- Добавляем не хватающие комбинации 3его и 6ого столбцов.  
- Остальные значения переменных для добавленных строк выберем любые, т.к. все комбинации значений каждой пары у нас уже есть.

![[Pasted image 20241105125533.png]]

Всё готово. Итого 8 комбинаций вместо 96.

[Сурс](https://w1zle.blogspot.com/2010/11/pairwise-testing-part-1-allpairs.html)
### Готовые инструменты:

1. [Список всех существующих инструментов для попарного тестирования](https://www.pairwise.org/tools.html)
2. [PairwiseTesting (тема)](https://pairwise.teremokgames.com/4s8/)
3. [Генератор на Ruby (2011г). Но вроде тоже ок](https://github.com/josephwilk/pairwise/wiki)
4. [Обзор на PICT - инструмент от Microsoft для попарного тестирования](https://www.software-testing.ru/library/testing/general-testing/1559-pairwise-testing-with-pict)

---
#орттогональные_массивы #orthogonal_arrays #попарное_тестирование 
# Попарное тестирование - Ортогональные массивы

Техника тест-дизайна Orthogonal Arrays - один из вариантов Pairwise testing.

**_Ортогональный массив_** - это 2-х мерный массив, с таким интересным свойством - выберите любые 2 столбца массива и найдете в них все комбинации значений этих столбцов.

*@:*
Сколько комбинаций существует для пары значений "1" и "2"? 
- {1,1}, {1,2}, {2,1} и {2,2}

Т.е. если мы возьмем 2 столбца из ортогонального массива, в которых могут быть значения только "1" или "2", то найдем следующие строки для этих столбцов - {1,1}, {1,2}, {2,1} и {2,2}.

*@:*
У нашего приложения 3 входных параметра, причем каждый бинарный (принимает значение "1" или "2"). 
Все возможные комбинации входных данных:

![[Pasted image 20241106102724.png]]

А ортогональный массив для этих данных будет выглядеть так:

![[Pasted image 20241106102804.png]]
##### Проверка:
- Возьмем столбец 1 и 3, и посмотрим, есть ли в них все комбинации этих столбцов (значения {1,1}, {1,2}, {2,1} и {2,2}) - да, есть. 
- Возьмем столбец 1 и 2, и посмотрим, есть ли в них все комбинации значений этих столбцов (опять же значения {1,1}, {1,2}, {2,1} и {2,2}) - да есть. 
- Возьмем столбец 2 и 3, и посмотрим, есть ли есть ли в них все комбинации значений этих столбцов ({1,1}, {1,2}, {2,1} и {2,2}) - да есть. 

Это ортогональный массив.

---
Записывается он в таком виде (см ниже), где *L4* означает, что ортогональный массив с 4 строками, *2^3* - это не степень, это означает, что у массива 3 столбца, в котором значения могут быть "1" или "2" (пишется max значение)

![[Pasted image 20241106103320.png]]

---
*@:*
Давайте возьмем ортогональный массив побольше. Допустим у нас есть 5 входных данных, каждое может принимать значения "1", "2" или "3". Как много существует пар для значений"1", "2" и "3"?
- {1,1}, {1,2}, {1,3}, {2,1}, {2,2}, {2,3}, {3,1}, {3,2}, и {3,3}

Рассмотрим L9(3^5) ортогональный массив:

![[Pasted image 20241106111438.png]]
_Всего возможных комбинаций в этом случае 243_
### Дополняя определение

Если какая то пара значений  2х столбцов встречается несколько раз, то все возможные парные комбинации значений этих столбцов должны встретится столько же раз. Это происходит потому что ортогональный массив должен быть сбалансирован.

Посмотрите на столбцы 3 и 5 - найдите комбинацию (3,2). Эта комбинация встречается в строках 6 и 17. Значит для этих столбцов, все возможные комбинации значений( а это {1,1}, {1,2}, {1,3}, {2,1}, {2,2}, {2,3}, {3,1}, {3,2}, и {3,3}) встретятся дважды

### Смешанные ортогональные массивы

В ортогональных массивах необязательно все столбцы должны иметь одинаковое количество значений. 

Существуют смешанные (mixed) ортогональные массивы.

Следующий массив - смешанный ортогональный массив L`18`(2`^1`3`^7`). 
У него 2 столбца со значениями "1" и "2" и 7 столбцов со значениями "1", "2", "3".

![[Pasted image 20241106112548.png]]

*@:*
определить как составить тест-кейсы для следующих входных данных:
- 2 ОС: Windows, Linux  
- 2 браузера: Chrome, FireFox  
- 2 веб сервера: Apache, WebLogic

Итоговая таблица:
![[Pasted image 20241106115327.png]]

---
## Использование ортогональных массивов

**1. Определите переменные (кол-во входных данных)**  
Важно: необходимо выбирать входные данные, любые комбинации значений которых, могут логически существовать. Например, если нам нужно проверить на браузерах: IE и FF, и операционных системах Linux и Windows, то мы явно не сможем проверить работу сайта под линухом в IE (ну или это лишено логического смысла). В этом случае необходимо сделать 2 ортогональных массива с браузерами для линуха и windows.  
  
**2. Определите количество значений, которое может принимать каждая переменная**  
Важно: К моменту определения количества значений вы уже должны применить всевозможные техники тест дизайна для уменьшения количества значений - классы эквивалентности, граничные значения и др. Например, если переменная может принимать значения от 1 до 100, то ортогональный массив, в котором 1 столбец может принимать 100 значений очень существенно разрастется, по сравнению с ортогональным массивом, где вы разбили 100 значений на классы эквивалентности и теперь эта переменная может принимать, скажем, 5 значений - 5 диапазонов классов эквивалентности.  
  
**3. Определите ортогональный массив**, у которого будет столбец для каждой переменной (каждый столбец ортогонального массива имеет столько же вариантов значений, сколько имеет ваша переменная).  
  
**4. Спроецируйте (map) задачу тестирования** на ортогональный массив.  
Важно : шаги 3 и 4 успешно делают различные утилиты. Вам всего лишь нужно вбить в нее какие входные данные могут быть, например так:  
- Journey mode: Return trip, One way  
- Preferred time: Morning, Afternoon, Evening, Late night  
- Leaving from: Type1_City,Type2_City,Type3_City  
- Going to : Type1_City,Type2_City,Type3_City  
- Booking type : Economy, First class  
- Customer type: Registered, New  
- Adults : 1, 2, 3, 4, 5, 6  
- Children : 0, 1, 2, 3, 4  
Все остальное утилита сделает сама и вам останется перейти к 5 шагу.  
  
**5. Постройте тест кейсы.**


[Сурс1](https://w1zle.blogspot.com/2010/11/pairwise-testing-part-1-orthogonal.html)
[Более просто + примеры](https://www.guru99.com/ru/orthogonal-array-testing.html)
[Построение алгоритма поиска покрытия различной глубины (не только 2)](https://habr.com/en/articles/187882/)

---
#таблица_решений #decision_table
# Таблица решений

**Decision Tables** - хороший инструмент для *фиксирования требований* и *описания функциональности* приложения. (Особенно когда нет адекватной документации)

Этими таблицами очень удобно описывать бизнес логику приложения, и в добавок они могут служить отличной основой для создания тест кейсов.

Decision Tables описывают логику приложения основываясь сущностях (свойствах/условиях) состояния системы. Каждая decision table должна описывать 1 состояние системы. Шаблон таблицы решений следующий:

![[Pasted image 20241107120114.png]]

**Сущность (conditions)** от 1 до m -  входные данные, которые можно ввести в систему

**Действия(actions)** от 1 до n - это действия которые могут произойти с указанной комбинацией сущностей, в зависимости от комбинации всех входных данных сущностей, действия принимают нужные значения

**Правило** - уникальный набор входных данных всех свойств, которые приводят к исполнению конкретных действий

***Создание тест-кейсов по таблице:***
Правило для создания тест кейсов просто - создайте как минимум 1 тест кейс на каждое правило в таблице. Просто поменяйте имена столбцов:
- *Правило* на тест-кейс
- *Сущность* на входные данные
- *Действия* на ОР

## Пример 1

*Ситуация:* тестирование приложения для страховой компании. Это приложение вычисляет скидку на страхование автомобилей, взаимозависимости от того, был ли водитель хорошим студентом и состоит ли он в браке

Как вычисляется скидка от этих условий покажем сразу с помощью decision table

#### Шаг 1: Сущности

Начнем со *сущностей*, их у нас всего 2 - был ли клиент хороший студент и состоит ли в браке. Каждое из свойств бинарное - т.е. может принимать значение либо true либо false

![[Pasted image 20241128133719.png]]

Получились все возможные комбинации - 4 правила

#### Шаг 2: правила

Теперь *действия*: в зависимости от комбинации значений наших сущностей у нас вычисляется скидка - то есть скидка - это результат взаимодействия сущностей

![[Pasted image 20241128133935.png]]

#### Итоговая таблица с тест-кейсами

![[Pasted image 20241128134046.png]]

или

![[Pasted image 20241128134102.png]]

## Пример 2

*Ситуация:* тестируем форму регистрации студентов. С помощью этой формы мы можем создавать, редактировать и удалять студентов из БД. Чтобы создать нового студента нужно ввести его имя, фамилию, адрес и нажать кнопку enter. Запись о студенте будет сохранена в БД и приложение вернет ID новосозданного студента.

Для того чтобы отредактировать или удалить данные студента нужно ввести ID студента и выбрать радиобуттон Modify или Delete соответственно.

![[Pasted image 20241128141540.png]]


#### Итоговый вид таблицы решений

![[Pasted image 20241128141807.png]]

_Все сущности и действия специально сведены к бинарным значениям для простоты примера. В реальной жизни такие сущности как "данные о студенте", "ID студента" должны быть разобраны на сущности и представлены различными символьными и численными значениями, выбранными определенным образом_
#### Упрощаем

Зачастую можно упростить таблицу. Например убрать невозможные варианты - мы никогда не сможем указать одновременно кнопки modify и delete 

таких невозможных правила у нас четыре  - 4, 8, 12, 16

**После исправления:**

![[Pasted image 20241128142031.png]]
#### Преобразовываем в тест-кейсы

![[Pasted image 20241128142132.png]]

https://w1zle.blogspot.com/2010/11/2-equivalence-class-testing-boundary.html

---
#state-transition #тестирование_состояний-переходов
# Тестирование состояний-переходов

Состояния-переходов, как и таблица решений, отличный инструмент для *фиксирования требований и описания дизайна приложения*. В отличии от Decision tables testing, которые описывают конкретное состояние приложения, состояния-переходы описывают как эти состояния приложения могут меняться. 

Диаграммы определяют все события, которые возникают во время работы приложения, и как приложение реагирует на эти события.

**Подход**
 * State-Transition Diagrams (диаграмы)  
 * State-Transition Tables (таблицы)

![[Pasted image 20241128145312.png]]
#### Понятия диаграммы:
1. **Состояние (круг)** - состояние приложения после одного или нескольких событий (стрелок)
	- состояние помнит входные данные полученные до этого и показывает как приложение будет реагировать на полученные события
	- события (*стрелки*) могут менять состояние (*круг*) и/или инициировать действия (*"/"*)
2. **Переход (стрелка)** - переход одного *состояния* в другое, происходящий по *событию*
3. **Событие (подпись стрелки)** - процесс, заставивший приложения поменять свое состояние. 
	- события могут поступать извне через интерфейсы приложения
	- приложение может само генерировать события (*@:* истек таймер)
	- после события приложение может поменять свое состояние (*@:* Made -> Paid) или остаться в том же состоянии, но выполнить действие (*"/"*)
	- Событие может иметь параметры (*@:* PayMoney: "Cash", "Check", "Debit Card")
4. **Действие ("/")** - действие, инициированное сменой состояния
	- *@:* "напечатать билет", "показать на экране"
	- обычно создают *выходные данные* приложения
	- возникают при переходе системы
5. **Точка входа** - черная точка. Начальное состояние системы
6. **Точка выхода** - показана как мишень. Конечное желаемое состояние системы

### Диаграммы

*Ситуация:* тестирования резервации авиабилетов. 

Сначала, мы как клиенты, предоставляем авиакомпании информацию для резервации - место отправления, место прибытия, дату и время отправления. Служащий авиакомпании служит интерфейсом между нами и системой резервации авиабилетов, и использует предоставленную нами информацию для создания резервации. После этого наша резервация находиться в состоянии "Made" (сделана). 

Вдобавок, после создания резервации, система резервации, запускает таймер. Если таймер выходит, а зарезервированный билет не оплачен - система отменяет резервацию.

**Диаграмма будет выглядеть так:**

##### 1. Начало работы

![[Pasted image 20241128143244.png]]

**Круг** - состояние системы резервации авиабилетов
- в данном случае - "Made"

**Стрелка** - показывает переход в состояние "Made"
- описание *"giveInfo"* - событие, исходящее из вне системы
- после giveInfo идет *"/"* - говорит, что система сделало какое-то действие в ответ на событие. В данном случае событие - запуск таймера (*"startPayTimer"*)
- *черная точка* - начало/вход в диаграмму

##### Если таймер не истек и зарезервированный билет оплачен, то система приобретает **состояние "Paid"**:

![[Pasted image 20241128144052.png]]

- событие оплаты билета показано стрелкой *"PayMoney"* и переходом в состояние *"Paid"*

##### 3. После оплаты происходит печать билета "Ticketed"

![[Pasted image 20241128150158.png]]

- при переходе в состояние "Ticketed", авиабилет (Ticket) является входными данными состояния

##### 4. При сдаче билета (посадка в самолет) переходим в состояние "Used"

![[Pasted image 20241128150420.png]]

##### 5. Конец работы алгоритма системы

![[Pasted image 20241128150519.png]]

##### 6. Алгоритм действий при истекшем таймере

![[Pasted image 20241128150615.png]]

##### 7.Добавление возможности отмены брони пользователем

![[Pasted image 20241128152701.png]]

##### 8. Отмена покупки билета после совершения оплаты

![[Pasted image 20241128152813.png]]

- стоимость билета клиенту возмещают (*/Refund*)
##### 9. Возврат билета после выдачи

![[Pasted image 20241128153020.png]]

- опять становиться "Cancelled By Customer"
- возмещает стоимость билета клиенту, НО только тогда, когда клиент вернет билет
- В таком случае применяется элемент диаграммы **"\[]"** - представляют условие к переходу: *"\[return Ticket]"*
- Переход в состояние в этом случае случится только если условие (то что в " [ ] ") =  true

*Замечание:*
Следует также прописать последовательность действий для выхода из состояния *"Cancelled NonPay"* и *"cancelled ByCust"*

### Таблицы

Не такой наглядный вид, но более полный и систематизированный

***Главное преимущество:*** табличный вид определяет все возможные переходы-состояния варианты, а не только валидные. Поэтому State-Transition таблицы часто приводят к нахождению не определенных, не документированных State-Transition комбинаций, которые лучше находить перед написанием кода.
#### State-transition tables состоит из четырех столбцов:
- Текущее состояние (Current State)
- Событие (Event)
- Действие (Action)
- Следующее состояние (next state)

**Перенесем вид системы из диаграммы в табличный:**

![[Pasted image 20241128154013.png]]
![[Pasted image 20241128154027.png]]

### Создание тест-кейсов

Из **диаграмм состояний-переходов** необходимо создать набор тест-кейсов, который должен пройти по всем переходам хотя бы раз

![[Pasted image 20241128154304.png]]

Из **таблиц состояний-переходов** тоже легко делать тест-кейсы

Стоит пройтись по всем валидным комбинациям (если есть время или не позволяют рискиможно пройтись и по всем невалидным комбинациям). В таблице отмечены все валидные комбинации жирным:

![[Pasted image 20241128154559.png]]
![[Pasted image 20241128154619.png]]

https://w1zle.blogspot.com/2010/11/state-transition-testing.html

---

[Техники тест дизайна (Confluence)](https://confluence.senlainc.com/pages/viewpage.action?pageId=2752694)

