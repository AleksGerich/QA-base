---
tags:
---

---
#бд_факты
# БД факты

- **`=`** используется для точного совпадения, а **`LIKE`** — для поиска по шаблону в строках
- **Нормальный вид базы данных (НФ)** — это набор правил и критериев для структурирования базы данных, чтобы устранить избыточность данных и повысить целостность данных. Эти правила применяются к реляционным базам данных для того, чтобы организовать данные таким образом, чтобы минимизировать дублирование и зависимость между данными

### Порядок написания запроса SQL:
1. SELECT
2. FROM
3. WHERE
4. GROUP BY
5. HAVING
6. ORDER BY
### Порядок выполнения запроса SQL:
1. FROM
2. WHERE
3. GROUP BY
4. HAVING
5. SELECT
6. ORDER BY

![[Pasted image 20241125102914.png]]

***JDBC (DriverManager.getConnection)*** - библиотека Java для взаимодействия сервера с БД

---
#нормализация
# Нормализация БД

#### Основные процессы:
- устранение избыточности данных
- устранение аномалий при добавлении, обновлении, удалении
- поддержание логической связи между таблицами

## Первая нормальная форма (1НФ)

###### Не должно быть дубликатов и составных данных

![[Pasted image 20241128163527.png]]

## Вторая нормальная форма (2НФ)

###### У каждой записи в базе данных должен быть первичный ключ (PK)

![[Pasted image 20241128163744.png]]

Номер чека - PK

## Третья нормальная форма (3НФ)

###### В записи не должно быть столбцов с неключевыми значениями, которые зависят от других неключевых значений

![[Pasted image 20241128164040.png]]

---
#целостность_БД
# Целостность БД

Целостность базы данных - это свойство, обеспечивающее корректность, точность и согласованность данных в системе. Предотвращает ошибок данных

## 1. Целостность сущностей (PK)

1. Гарантирует, что каждая строка в таблице имеет уникальный идентификатор.
2. Обычно обеспечивается использованием **первичного ключа (Primary Key)**:
    - Значение первичного ключа должно быть **уникальным**.
    - Первичный ключ не может содержать **NULL**.

![[Pasted image 20241128171609.png]]

## 2. Ссылочная целостность (связь ключей)

1. Обеспечивает корректность ссылок между таблицами через **внешние ключи (Foreign Keys)**.
2. Значение внешнего ключа должно:
    - Либо совпадать с существующим значением первичного ключа в связанной таблице.
    - Либо быть **NULL**.

![[Pasted image 20241128171757.png]]

## 3. Целостность Домена (столбца)

1. Гарантирует, что значения в столбце соответствуют определенному типу данных, диапазону или списку допустимых значений.
2. Достигается использованием:
    - Ограничений типов данных (например, INTEGER, VARCHAR).
    - Проверочных ограничений (CHECK).
    - Правил уникальности (UNIQUE).

![[Pasted image 20241128172338.png]]

## 4. Пользовательская целостность (бизнес-логика)

- Определяется специфическими правилами бизнеса или логикой приложения.
- Реализуется с помощью триггеров, процедур или других программных средств.

**Пример:**
- В таблице "Заказы" сумма заказа не может превышать определенное значение.
- Или, например, доставка не может быть назначена на выходные.

#### Способы обеспечения целостности

1. **Ограничения (Constraints):**
- PRIMARY KEY: уникальный идентификатор строки.
- FOREIGN KEY: поддержание связей между таблицами.
- UNIQUE: предотвращение дублирования данных.
- CHECK: проверка значений по правилам.
- NOT NULL: предотвращение пустых значений.

2. **Триггеры:**
- Автоматическое выполнение действий при добавлении, изменении или удалении записей

3. **Транзакции:**
- Группы операций, которые выполняются как единое целое. Если одна операция не выполнится, транзакция откатывается.

3. **Правильный дизайн схемы базы данных:**
- Нормализация и использование правильных типов данных.

---
#индексы
# Индексы

**Индекс** — это структура данных, создаваемая для увеличения производительности операций поиска. По сути, это отдельная структура, которая хранит ссылки на строки таблицы и помогает быстро находить нужные записи, аналогично тому, как оглавление книги помогает быстро находить нужную главу.

Когда запрос использует колонку, на которой есть индекс, система ищет данные через индекс, а не просматривает все записи в таблице последовательно.

#### Плюсы индексов:
- **Ускорение запросов**: Индексы позволяют базе данных быстро находить нужные строки, минуя полное сканирование таблицы.
- **Оптимизация операций выборки**: Особенно эффективны при работе с большими таблицами, где без индексов поиск может занимать значительно больше времени.

#### Минусы индексов (в общем): 
- **Затраты на хранение**: Индексы требуют дополнительного пространства на диске, так как создается отдельная структура данных.
- **Замедление вставки/обновления/удаления данных**: При каждом изменении данных в таблице индекс тоже должен обновляться, что может замедлить операции вставки и обновления.

#### Разновидности индексов

1.  ***Кластеризованные***
		
	- все значения при кластеризованном индексе *отсортированы* (либо по возрастанию, либо по убыванию)
		
	- Кластеризированный индекс может быть *только один*
		
	- Упорядоченные кластеризованным индексом данные в таблице *хранятся физически*, что увеличивает скорость поиска, но тратит память
		
	- При изменении данных таблиц меняется порядок -> индексированная таблица перестраивается, что является *затратным процессом*
		
2. ***Некластеризованные***
		
	- применяется к *неключевым столбцам*
		
	- *не упорядочивает данные физически*. Он хранит данные и индексы в разных местах
		
	- Листья некластеризованного индекса содержат только те столбцы таблицы, по которым определен данный индекс. Это означает, что системе запросов необходима дополнительная операция для извлечения требуемых данных.
		
	- Некластеризованные индексы нельзя отсортировать 
		
	- Можно создать более одного некластеризованного индекса
		
	- При использовании некластеризованного индекса можно добавить уникальный ключ для таблицы.

![[Pasted image 20241021130235.png]]

#### Основные типы индексов

1. **Обычные (B-tree) индексы**
	- Это наиболее распространенный тип индексов, основанный на **B-деревьях**. Он хранит данные в отсортированном порядке, что ускоряет поиск, вставку и удаление данных (хорошо подходят для равенства и диапазонных запросов)
2. **Уникальные индексы (Unique index)**:
	- Гарантируют, что все значения в проиндексированной колонке будут уникальными. 
	- (@: PRIMARY KEY)
3. **Неуникальный (Non-unique index)**:
	- индекс, при котором значения могут повторяться
4. **Полнотекстовые индексы (Full-text)**:
	- Эти индексы предназначены для быстрого поиска текста в больших объемах текстовых данных. Они полезны для поиска по ключевым словам или фразам, как в случае поиска по статьям, книгам или заметкам
5. **Хэш-индексы**:
	- В некоторых СУБД (например, в MySQL для таблиц с движком **Memory**) используются **хэш-индексы**, которые обеспечивают доступ к данным по точному значению столбца. В отличие от B-tree индексов, хэш-индексы не поддерживают диапазонные запросы. 
	- (@: SELECT * FROM table WHERE column = 'value')
6. **Составные (многоколонковые) индексы**:
	- Это индексы, создаваемые сразу на нескольких столбцах. Они полезны, когда запросы часто фильтруют данные по нескольким колонкам одновременно. В данном типе индекса расположение полей является важным.

---
#Функции 
# Фунции

### 1. Агрегатные функции
Выполняют вычисления над набором строк и возвращают одно значение. Они обычно используются в комбинации с оператором `GROUP BY` для выполнения групповых операций

- **`COUNT()`** — подсчитывает количество строк.
- **`SUM()`** — вычисляет сумму значений.
- **`AVG()`** — вычисляет среднее значение.
- **`MAX()`** и **`MIN()`** — находят максимальное и минимальное значение соответственно.

### 2. Скалярные функции
Принимают одно или несколько значений и возвращают одно значение.

- **Строковые функции**:
    - **`UPPER()`** / **`LOWER()`** — перевод текста в верхний или нижний регистр.
    - **`SUBSTRING()`** — возвращает часть строки.
    - **`LENGTH()`** — возвращает длину строки.
- **Математические функции**:
    - **`ABS()`** — возвращает модуль числа.
    - **`ROUND()`** — округляет число до указанного количества знаков.
    - **`SQRT()`** — вычисляет квадратный корень.
- **Функции работы с датами**:
    - **`NOW()`** — возвращает текущую дату и время.
    - **`DATEADD()`** — добавляет указанное количество времени к дате.
    - **`DATEDIFF()`** — вычисляет разницу между двумя датами.

### 3. Пользовательские функции (UDF - User-Defined Functions)
Функции, которые пользователь может создавать самостоятельно для выполнения специфических операций. Они могут принимать параметры и возвращать значения, что делает их удобными для повторного использования.

**Пользовательские функции могут быть:**
- **детерминированными** (результат всегда один и тот же для одинаковых входных данных)
- **недетерминированными** (результат может меняться при каждом выполнении)

@:
CREATE FUNCTION get_full_name(first_name VARCHAR(50), last_name VARCHAR(50)) RETURNS VARCHAR(100) 
BEGIN 
	RETURN CONCAT(first_name, ' ', last_name); 
END;

### 4. Конвертирующие функции
Преобразуют данные из одного типа в другой

- **`CAST()`** и **`CONVERT()`** — используются для преобразования одного типа данных в другой.

### 5. Функции работы с NULL значениями
Помогают работать с `NULL` значениями, которые могут представлять отсутствующие или неопределённые данные

- **`ISNULL()`** или **`COALESCE()`** — возвращает первое ненулевое значение из списка аргументов.

### 6.Функции окон (Window functions)
Используются для выполнения операций над группой строк, но в отличие от агрегатных функций, они не сводят результат к одному значению

- **`ROW_NUMBER()`** — возвращает номер строки в рамках окна.
- **`RANK()`** — возвращает ранг строки.
- **`LAG()`** и **`LEAD()`** — возвращают предыдущее или следующее значение относительно текущей строки.

---
#операторы
# Операторы

В SQL операторы можно разделить на несколько категорий, каждая из которых соответствует определённому типу операций с данными. В контексте стандартов SQL, эти категории часто упоминаются как **DDL**, **DML**, **DCL** и **TCL**.

### 1. DDL (Data Definition Language) — Язык определения данных
Используются для создания и изменения структур баз данных, таких как таблицы, индексы, представления и т.д. Они определяют структуру базы данных.

- **`CREATE`** — создаёт новый объект в базе данных (например, таблицу, индекс)
	@: 
	CREATE TABLE employees ( 
		id INT PRIMARY KEY, 
		name VARCHAR(100), 
		salary DECIMAL(10, 2) 
	);
- **`ALTER`** — изменяет существующую структуру объекта (например, добавляет столбец в таблицу).
	@: ALTER TABLE employees ADD department VARCHAR(50);
- **`DROP`** — удаляет объект базы данных (например, таблицу)
	@: DROP TABLE employees;
- **`TRUNCATE`** — удаляет все строки из таблицы, но сохраняет её структуру
	@: TRUNCATE TABLE employees;

### 2. DML (Data Manipulation Language) — Язык манипуляции данными
Используются для работы с данными, хранящимися в таблицах. Они позволяют добавлять, изменять, удалять и выбирать данные

- **`SELECT`** — выбирает данные из одной или нескольких таблиц.
	@: SELECT * FROM employees;
- **`INSERT`** — добавляет новые строки данных в таблицу
	@: INSERT INTO employees (name, salary) VALUES ('John Doe', 50000);
- **`UPDATE`** — обновляет существующие данные в таблице
	@: UPDATE employees SET salary = 55000 WHERE name = 'John Doe';
- **`DELETE`** — удаляет данные из таблицы
	@: DELETE FROM employees WHERE name = 'John Doe';

### 3. DCL (Data Control Language) — Язык управления доступом
Используются для управления правами пользователей на объекты базы данных. С их помощью можно предоставлять или отнимать доступ к данным

- **`GRANT`** — предоставляет пользователю права на выполнение определённых операций
	@: GRANT SELECT, INSERT ON employees TO 'user1';
- **`REVOKE`** — отзывает права, ранее предоставленные пользователю
	@: REVOKE SELECT ON employees FROM 'user1';

### 4. TCL (Transaction Control Language) — Язык управления транзакциями
Используются для управления транзакциями в базе данных. Транзакция — это группа операций, которые либо выполняются все, либо не выполняется ни одна из них.

- **`COMMIT`** — фиксирует изменения, сделанные во время транзакции
	@: COMMIT;
- **`ROLLBACK`** — отменяет изменения, сделанные в текущей транзакции
	@: ROLLBACK;
- **`SAVEPOINT`** — устанавливает точку сохранения внутри транзакции, к которой можно вернуться с помощью `ROLLBACK`
	@: SAVEPOINT save1;

### 5. DQL (Data Query Language) — Операторы управления данными
Хотя формально DQL выделяют как отдельную категорию, в неё фактически включён только оператор **`SELECT`**, который используется для выборки данных

**Примеры использования:**
1. **DDL** — это когда вы создаёте таблицу или изменяете её структуру.
2. **DML** — это когда вы добавляете данные в таблицу, обновляете их или удаляете.
3. **DCL** — это когда вы управляете доступом к данным, предоставляя права пользователям.
4. **TCL** — это когда вы управляете транзакциями, которые могут включать несколько операторов DML, таких как `INSERT`, `UPDATE`, или `DELETE`, чтобы гарантировать целостность данных.

---
#транзакции
# Транзакции в SQL

**Транзакции в SQL** — это группа операций с базой данных, которые выполняются как единое целое. Если все операции в транзакции успешно завершены, изменения фиксируются в базе данных, если хотя бы одна операция завершилась ошибкой, все изменения откатываются, и база данных возвращается к исходному состоянию

**Транзакция** - это осуществление одного или нескольких изменений базы данных. Например, если вы создаете, обновляете или удаляете запись из таблицы, вы выполняете в этой таблице транзакцию. Важно контролировать транзакции, чтобы обеспечить целостность данных и обрабатывать ошибки базы данных.

Практически вы собираете множество SQL-запросов в группу, и они будут выполняться вместе как часть транзакции.
## Основные операторы, связанные с транзакциями:

- **BEGIN/START TRANSACTION**: начинает новую транзакцию.
    
- **COMMIT**: завершает транзакцию и фиксирует все изменения в базе данных.
    
- **ROLLBACK**: откатывает все изменения, сделанные в транзакции, если произошла ошибка или если нужно отменить транзакцию.
    
- **SAVEPOINT**: позволяет создать промежуточную точку в транзакции, к которой можно вернуться, не отменяя всю транзакцию.
    
- **RELEASE SAVEPOINT**: удаляет ранее созданную точку сохранения.
    
- **SET TRANSACTION**: устанавливает характеристики для текущей транзакции, например уровень изоляции.

@:
BEGIN TRANSACTION; 

INSERT INTO users (name, age) VALUES ('Alice', 30); 
UPDATE accounts SET balance = balance - 100 WHERE user_id = 1; 

COMMIT;

**Нюансы:**
- Если ни `COMMIT`, ни `ROLLBACK` не будут выполнены, транзакция останется незавершенной, и система может зависнуть или выдать ошибку в будущем.
- После `COMMIT`, даже если вы создали несколько точек сохранения с `SAVEPOINT`, откат к этим точкам уже невозможен.
- Таким образом, после `COMMIT` транзакция считается завершённой, и любые изменения, сделанные в её рамках, невозможно отменить с помощью `ROLLBACK`.
- Если транзакция не явная, СУБД может автоматически выполнить `COMMIT` после каждой операции.

Все ли операции являются транзакциями? - Да, но только неявным образом
**Но**
- В большинстве баз данных простые операции, такие как `INSERT`, `UPDATE`, или `DELETE`, выполняются автоматически в рамках неявной транзакции. Это означает, что каждая операция автоматически завершается `COMMIT`-ом, даже если `BEGIN TRANSACTION` не был явно вызван.
- В случае явной транзакции вы используете команды `BEGIN TRANSACTION`, `COMMIT` и `ROLLBACK` для управления целостностью нескольких связанных операций. Только после выполнения `COMMIT` данные фиксируются в базе, и если что-то пошло не так, вы можете откатить транзакцию с помощью `ROLLBACK`.

---
# UNION и EXEPT

UNION - объединение нескольких запросов. Выводит поочередно результаты первого запроса, затем результаты второго
@:
Получить информацию о моделях производителей A и B.
SELECT * FROM product
WHERE maker = 'A'
*UNION*
SELECT * FROM product
WHERE maker = 'B';


EXEPT - разность (по типу NOT). Выводит результат за исключением выбранной категории в разделе EXEPT:
@:
Найти модели, которые не являются ПК
SELECT * FROM product
*EXCEPT*
SELECT * FROM product 
WHERE type = 'pc';

---
#union
# Ограничения UNION

1. Порядок столбцов, тип столбцов, число столбцов **должны совпадать**
2. Нельзя использовать подзапросы

---
